<!doctype html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <title>Pro CSV Viewer v6 (High Contrast Selection)</title>
    <link rel="stylesheet" href="uPlot.min.css" />
    <script src="uPlot.iife.min.js"></script>

    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #121212;
        color: #eee;
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
      }


      /* --- LOADING SPINNER --- */
      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #555;
        border-top: 2px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 5px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* --- ВІЗУАЛІЗАЦІЯ ВИДІЛЕННЯ (НОВЕ) --- */
      .u-select {
        background: rgba(0, 123, 255, 0.3) !important;
        border: 1px solid #007bff !important;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      }

      /* --- SIDEBAR --- */
      .sidebar {
        width: 300px;
        background: #1e1e1e;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        padding: 15px;
        box-sizing: border-box;
        flex-shrink: 0;
        overflow-y: auto;
      }

      .logo {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #fff;
      }
      .logo span {
        color: #007bff;
      }

      .btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        color: white;
        transition: 0.2s;
      }
      .btn-primary {
        background: #007bff;
      }
      .btn-primary:hover {
        background: #0056b3;
      }

      .btn-icon {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 2px;
        cursor: pointer;
        border: none;
        border-radius: 3px;
        color: white;
      }
      .btn-settings {
        background: #f59f00;
      }
      .btn-neutral {
        background: #555;
      }
      .btn-fit {
        background: #2f9e44;
      }
      .btn-del {
        background: #e03131;
      }

      .dataset-list {
        margin-top: 20px;
        border-top: 1px solid #333;
        padding-top: 10px;
      }
      .dataset-item {
        background: #252525;
        border: 1px solid #333;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 8px;
        position: relative;
      }
      .dataset-item.not-ready {
        border-left: 3px solid #f59f00;
        opacity: 0.9;
      }
      .dataset-item.ready {
        border-left: 3px solid #2f9e44;
      }
      .dataset-item.master {
        border-left: 3px solid #007bff;
      }
      .dataset-item.loading {
        border-left: 3px solid #777;
        opacity: 0.7;
      }

      .ds-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }
      .ds-name {
        font-size: 13px;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 140px;
      }
      .ds-status {
        font-size: 10px;
        color: #aaa;
        margin-top: 2px;
      }

      /* --- MAIN AREA --- */
      .main-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #000;
        overflow: hidden;
        position: relative;
      }

      #hoverInfo {
        height: 30px;
        background: #111;
        border-bottom: 1px solid #333;
        display: flex;
        gap: 20px;
        align-items: center;
        padding: 0 10px;
        font-family: monospace;
        font-size: 14px;
        color: #aaa;
        flex-shrink: 0;
      }
      #chart {
        flex: 1;
        width: 100%;
        height: 100%;
        position: relative;
        cursor: crosshair;
      }

      .jump-panel {
        height: 150px;
        background: #1a1a1a;
        border-top: 1px solid #333;
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
      }
      .jump-tabs {
        display: flex;
        gap: 2px;
        padding: 5px;
        background: #222;
        flex-wrap: wrap;
      }
      .jump-tab {
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
        border-radius: 3px 3px 0 0;
        background: #333;
        color: #888;
        border: none;
      }
      .jump-tab:hover {
        background: #444;
        color: #fff;
      }
      .jump-tab.active {
        background: #1a1a1a;
        color: #4dabf7;
        font-weight: bold;
      }
      .jump-tab .count {
        color: #ff6b6b;
        margin-left: 4px;
      }
      .jump-list {
        overflow-y: auto;
        flex: 1;
        padding: 5px;
      }
      .jump-item {
        display: inline-block;
        padding: 4px 8px;
        margin: 2px;
        background: #333;
        border-radius: 3px;
        font-size: 12px;
        font-family: monospace;
        cursor: pointer;
      }
      .jump-bad {
        color: #ff6b6b;
        font-weight: bold;
      }

      /* --- WARNING BANNER --- */
      .warning-banner {
        background: linear-gradient(90deg, #f59f00, #e67700);
        color: #000;
        padding: 8px 15px;
        font-size: 13px;
        font-weight: 500;
        display: none;
        align-items: center;
        gap: 10px;
        flex-shrink: 0;
      }
      .warning-banner.visible {
        display: flex;
      }
      .warning-banner .warning-icon {
        font-size: 16px;
      }
      .warning-banner .warning-text {
        flex: 1;
      }
      
      /* --- PAGE NAVIGATION --- */
      .page-nav {
        background: #1a1a1a;
        border-top: 1px solid #333;
        padding: 8px 15px;
        display: none;
        align-items: center;
        justify-content: center;
        gap: 15px;
        flex-shrink: 0;
      }
      .page-nav.visible {
        display: flex;
      }
      .page-nav-btn {
        background: #333;
        border: 1px solid #555;
        color: #fff;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      .page-nav-btn:hover:not(:disabled) {
        background: #444;
        border-color: #666;
      }
      .page-nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .page-nav-info {
        font-size: 13px;
        color: #aaa;
      }
      .page-nav-info strong {
        color: #4dabf7;
      }
      .page-nav-select {
        background: #2c2c2c;
        border: 1px solid #555;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
      }

      /* --- MODAL --- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        display: none;
        justify-content: center;
        align-items: center;
      }
      .modal {
        background: #252525;
        padding: 20px;
        border-radius: 8px;
        width: 400px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        border: 1px solid #444;
      }
      .modal h3 {
        margin-top: 0;
        margin-bottom: 15px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      .col-list {
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 15px;
        border: 1px solid #333;
        padding: 5px;
        background: #1a1a1a;
      }
      .col-item {
        display: grid;
        grid-template-columns: 30px 30px 1fr;
        gap: 10px;
        padding: 5px;
        border-bottom: 1px solid #333;
        align-items: center;
        font-size: 13px;
      }
      .col-header {
        display: grid;
        grid-template-columns: 30px 30px 1fr;
        gap: 10px;
        padding: 5px;
        font-weight: bold;
        font-size: 12px;
        color: #aaa;
        border-bottom: 1px solid #555;
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
      #fileInput {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="modal-overlay" id="configModal">
      <div class="modal">
        <h3>Налаштування колонок</h3>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 10px">
          Виберіть <b>одну</b> колонку для часу (X) і
          <b>будь-яку кількість</b> для даних (Y).
        </div>

        <div class="col-header">
          <span>X</span>
          <span>Y</span>
          <span>Назва колонки</span>
        </div>
        <div class="col-list" id="modalColList"></div>

        <div
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
          "
        >
          <label
            style="
              font-size: 12px;
              color: #aaa;
              display: block;
              margin-bottom: 5px;
            "
          >
            Очікувана частота (Hz) - для визначення аномалій:
          </label>
          <input
            type="number"
            id="modalFreq"
            placeholder="напр. 100000"
            style="
              width: 100%;
              background: #2c2c2c;
              border: 1px solid #444;
              color: white;
              padding: 8px;
              border-radius: 4px;
            "
          />
        </div>

        <!-- IMU Sensitivity Settings -->
        <div
          id="imuSettingsSection"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
            display: none;
          "
        >
          <div style="font-size: 12px; color: #4dabf7; margin-bottom: 10px; font-weight: bold;">
            ⚙️ Налаштування IMU сенсора (LSM6DS3)
          </div>
          <div style="display: flex; gap: 15px;">
            <div style="flex: 1;">
              <label style="font-size: 12px; color: #aaa; display: block; margin-bottom: 5px;">
                Діапазон акселерометра (±g):
              </label>
              <select
                id="modalAccelRange"
                style="
                  width: 100%;
                  background: #2c2c2c;
                  border: 1px solid #444;
                  color: white;
                  padding: 8px;
                  border-radius: 4px;
                "
              >
                <option value="2">±2g</option>
                <option value="4">±4g</option>
                <option value="8">±8g</option>
                <option value="16" selected>±16g</option>
              </select>
            </div>
            <div style="flex: 1;">
              <label style="font-size: 12px; color: #aaa; display: block; margin-bottom: 5px;">
                Діапазон гіроскопа (dps):
              </label>
              <select
                id="modalGyroRange"
                style="
                  width: 100%;
                  background: #2c2c2c;
                  border: 1px solid #444;
                  color: white;
                  padding: 8px;
                  border-radius: 4px;
                "
              >
                <option value="245">245 dps</option>
                <option value="500">500 dps</option>
                <option value="1000">1000 dps</option>
                <option value="2000" selected>2000 dps</option>
              </select>
            </div>
          </div>
          <div style="font-size: 11px; color: #666; margin-top: 8px;">
            LSB чутливість: Accel = range/32768 g/LSB, Gyro = range/32768 dps/LSB
          </div>
        </div>

        <div class="modal-footer">
          <button
            class="btn btn-del"
            style="width: auto"
            onclick="closeModal()"
          >
            Скасувати
          </button>
          <button
            class="btn btn-primary"
            style="width: auto"
            onclick="applyModalConfig()"
          >
            Застосувати
          </button>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="logo">⚡ CSV <span>Pro v6</span></div>

      <button
        class="btn btn-primary"
        onclick="document.getElementById('fileInput').click()"
      >
        + Завантажити .DATA  або .CSV
      </button>
      <input
        type="file"
        id="fileInput"
        accept=".csv,.dat"
        multiple
        onchange="handleFiles(this.files)"
      />

      <div class="dataset-list" id="datasetList"></div>
    </div>

    <div class="main-area">
      <!-- Warning Banner -->
      <div class="warning-banner" id="warningBanner">
        <span class="warning-icon">⚠️</span>
        <span class="warning-text" id="warningText">File truncated. Showing first 100,000 frames.</span>
      </div>
      
      <div id="hoverInfo">
        <div>TIME: <span id="dispTime" style="color: #4dabf7">-</span></div>
        <div id="dispValues" style="display: flex; gap: 15px"></div>
      </div>

      <div id="chart"></div>

      <!-- Page Navigation -->
      <div class="page-nav" id="pageNav">
        <button class="page-nav-btn" id="prevPageBtn" onclick="goToPage(-1)">◀ Попередня</button>
        <span class="page-nav-info">
          Сторінка <strong id="currentPage">1</strong> з <strong id="totalPages">1</strong>
          <select class="page-nav-select" id="pageSelect" onchange="goToPageDirect(this.value)"></select>
        </span>
        <button class="page-nav-btn" id="nextPageBtn" onclick="goToPage(1)">Наступна ▶</button>
      </div>

      <div class="jump-panel">
        <div class="jump-tabs" id="jumpTabs"></div>
        <div class="jump-list" id="jumpList"></div>
      </div>
    </div>

    <script>
      // === GLOBAL STATE ===
      const PALETTE = [
        "#ff00ff",
        "#00ccff",
        "#ffff00",
        "#ff6b6b",
        "#ffa500",
        "#00ffaa",
        "#aa00ff",
        "#ffffff",
        "#995500",
        "#ff0088",
      ];

      let datasets = [];
      let activeModalDatasetIndex = -1;
      let uplot = null;
      let jumps = [];
      let activeAnomalyTab = -1;
      
      // Pagination state
      const FRAMES_PER_PAGE = 100000;
      const FRAME_SIZE = 852;
      const HEADER_SIZE = 64;
      let activePaginatedDataset = null;  // Dataset with pagination
      let currentPageFile = null;  // File reference for lazy loading
      
      // IMU sensitivity settings (from LSM6DS3 sensor configuration)
      const imuSettings = {
          accelRangeG: 16,      // ±16g default (from LSM6DS3_CTRL1_XL_HIT_VAL)
          gyroRangeDps: 2000    // 2000 dps default (from LSM6DS3_CTRL2_G_HIT_VAL)
      };
      
      /**
       * Calculate derived IMU columns (Gforce and GyroS) from raw sensor data.
       * 
       * @param {Object} imuData - IMU parsed data with columns
       * @returns {Object} - Modified imuData with Gforce and GyroS columns added
       */
      function calculateImuDerivedColumns(imuData) {
          if (!imuData || !imuData.columns) return imuData;
          
          // Find required columns
          const findCol = (name) => imuData.columns.find(c => c.name.toLowerCase().includes(name));
          
          const accelX = findCol('accel_x') || findCol('ax');
          const accelY = findCol('accel_y') || findCol('ay');
          const accelZ = findCol('accel_z') || findCol('az');
          const gyroX = findCol('gyro_x') || findCol('gx');
          const gyroY = findCol('gyro_y') || findCol('gy');
          const gyroZ = findCol('gyro_z') || findCol('gz');
          
          const sampleCount = accelX ? accelX.data.length : (gyroX ? gyroX.data.length : 0);
          if (sampleCount === 0) return imuData;
          
          // Sensitivity factors (raw int16 -> real units)
          const accelScale = imuSettings.accelRangeG / 32768.0;
          const gyroScale = imuSettings.gyroRangeDps / 32768.0;
          
          // Calculate Gforce (absolute acceleration in G)
          if (accelX && accelY && accelZ) {
              const gforce = new Float64Array(sampleCount);
              for (let i = 0; i < sampleCount; i++) {
                  const ax = accelX.data[i] * accelScale;
                  const ay = accelY.data[i] * accelScale;
                  const az = accelZ.data[i] * accelScale;
                  gforce[i] = Math.sqrt(ax * ax + ay * ay + az * az);
              }
              imuData.columns.push({ name: 'Gforce', data: gforce });
              console.log(`Calculated Gforce (${sampleCount} samples, range ±${imuSettings.accelRangeG}g)`);
          }
          
          // Calculate GyroS (absolute rotation speed in dps)
          if (gyroX && gyroY && gyroZ) {
              const gyroS = new Float64Array(sampleCount);
              for (let i = 0; i < sampleCount; i++) {
                  const gx = gyroX.data[i] * gyroScale;
                  const gy = gyroY.data[i] * gyroScale;
                  const gz = gyroZ.data[i] * gyroScale;
                  gyroS[i] = Math.sqrt(gx * gx + gy * gy + gz * gz);
              }
              imuData.columns.push({ name: 'GyroS', data: gyroS });
              console.log(`Calculated GyroS (${sampleCount} samples, range ±${imuSettings.gyroRangeDps}dps)`);
          }
          
          return imuData;
      }
      
      // Worker setup
      
      // Load Wasm Log Parser Module
      let wasmModule = null;
      let wasmReady = false;
      
      // Wasm Helper Functions
      let wasm_parse_binary_log = null;
      let wasm_calculate_anomalies = null;
      let wasm_interpolate_to_master = null;
      
      var script = document.createElement('script');
      script.src = "log_parser.js";
      script.onload = function() {
          console.log("log_parser.js loaded, initializing module...");
          createLogParserModule().then(module => {
              wasmModule = module;
              wasmReady = true;
              console.log("Wasm Log Parser Module Initialized!");
              
              // Wrap exported functions
              wasm_parse_binary_log = module.cwrap('parse_binary_log', 'number', [
                  'number', 'number',  // buffer, buffer_len
                  'number',            // max_frames
                  'number', 'number',  // adc_time, adc_val
                  'number',            // imu_time
                  'number', 'number', 'number',  // imu_gx, gy, gz
                  'number', 'number', 'number',  // imu_ax, ay, az
                  'number', 'number'   // out_adc_count, out_imu_count
              ]);
              
              wasm_calculate_anomalies = module.cwrap('calculate_anomalies', 'number', [
                  'number', 'number',  // x_data, length
                  'number',            // threshold_us
                  'number', 'number',  // anomaly_indices, anomaly_diffs
                  'number'             // max_anomalies
              ]);
              
              wasm_interpolate_to_master = module.cwrap('interpolate_to_master', null, [
                  'number', 'number', 'number',  // src_x, src_y, src_len
                  'number', 'number',            // master_x, master_len
                  'number'                       // result
              ]);
              
              // Test
              const helloWorld = module.cwrap('hello_world', 'string', []);
              console.log("Wasm says:", helloWorld());
          });
      };
      document.head.appendChild(script);
      
      // Wasm Binary Parser Function (main thread)
      function parseBinaryWithWasm(buffer) {
          if (!wasmReady) {
              throw new Error("Wasm module not ready");
          }
          
          const M = wasmModule;
          const bufferLen = buffer.byteLength;
          
          // Estimate max samples
          const HEADER_SIZE = 64;
          const FRAME_SIZE = 852;
          const ADC_BLOCK_SIZE = 256;
          const IMU_BLOCK_SIZE = 20;
          const MAX_FRAMES = 100000;  // Limit to prevent memory exhaustion (matches C converter)
          
          let numFrames = Math.floor((bufferLen - HEADER_SIZE) / FRAME_SIZE);
          const totalFramesInFile = numFrames;
          let isTruncated = false;
          
          // Apply frame limit for very large files
          if (numFrames > MAX_FRAMES) {
              console.warn(`File has ${numFrames} frames, limiting to ${MAX_FRAMES} frames`);
              numFrames = MAX_FRAMES;
              isTruncated = true;
          }
          
          const maxAdcSamples = numFrames * ADC_BLOCK_SIZE;
          const maxImuSamples = numFrames * IMU_BLOCK_SIZE;
          
          // Calculate total memory needed (rough estimate)
          const totalMemoryNeeded = bufferLen + (maxAdcSamples * 8 * 2) + (maxImuSamples * 8 * 7) + 8;
          console.log(`Allocating ~${(totalMemoryNeeded / (1024*1024)).toFixed(1)}MB for Wasm parsing (${numFrames} frames)`);
          
          // Allocate memory in Wasm heap
          const bufferPtr = M._malloc(bufferLen);
          if (bufferPtr === 0) throw new Error("Failed to allocate input buffer");
          
          const adcTimePtr = M._malloc(maxAdcSamples * 8);  // Float64
          const adcValPtr = M._malloc(maxAdcSamples * 8);
          const imuTimePtr = M._malloc(maxImuSamples * 8);
          const imuGxPtr = M._malloc(maxImuSamples * 8);
          const imuGyPtr = M._malloc(maxImuSamples * 8);
          const imuGzPtr = M._malloc(maxImuSamples * 8);
          const imuAxPtr = M._malloc(maxImuSamples * 8);
          const imuAyPtr = M._malloc(maxImuSamples * 8);
          const imuAzPtr = M._malloc(maxImuSamples * 8);
          const outAdcCountPtr = M._malloc(4);  // uint32
          const outImuCountPtr = M._malloc(4);
          
          // Check all allocations succeeded
          if (!adcTimePtr || !adcValPtr || !imuTimePtr || !imuGxPtr || !imuGyPtr || 
              !imuGzPtr || !imuAxPtr || !imuAyPtr || !imuAzPtr || !outAdcCountPtr || !outImuCountPtr) {
              // Free what we allocated
              if (bufferPtr) M._free(bufferPtr);
              if (adcTimePtr) M._free(adcTimePtr);
              if (adcValPtr) M._free(adcValPtr);
              if (imuTimePtr) M._free(imuTimePtr);
              if (imuGxPtr) M._free(imuGxPtr);
              if (imuGyPtr) M._free(imuGyPtr);
              if (imuGzPtr) M._free(imuGzPtr);
              if (imuAxPtr) M._free(imuAxPtr);
              if (imuAyPtr) M._free(imuAyPtr);
              if (imuAzPtr) M._free(imuAzPtr);
              if (outAdcCountPtr) M._free(outAdcCountPtr);
              if (outImuCountPtr) M._free(outImuCountPtr);
              throw new Error("Failed to allocate Wasm memory for parsing. File may be too large.");
          }
          
          try {
              // Copy input buffer to Wasm heap
              M.HEAPU8.set(new Uint8Array(buffer), bufferPtr);
              
              const start = performance.now();
              
              // Call Wasm function
              const adcRateKhz = wasm_parse_binary_log(
                  bufferPtr, bufferLen,
                  numFrames,  // max_frames limit
                  adcTimePtr, adcValPtr,
                  imuTimePtr,
                  imuGxPtr, imuGyPtr, imuGzPtr,
                  imuAxPtr, imuAyPtr, imuAzPtr,
                  outAdcCountPtr, outImuCountPtr
              );
              
              const end = performance.now();
              console.log(`Wasm: Binary parsed in ${(end-start).toFixed(2)}ms`);
              
              // Read output counts
              const adcCount = M.HEAPU32[outAdcCountPtr >> 2];
              const imuCount = M.HEAPU32[outImuCountPtr >> 2];
              
              // Copy results to JS arrays
              const adcTime = new Float64Array(M.HEAPF64.buffer, adcTimePtr, adcCount).slice();
              const adcVal = new Float64Array(M.HEAPF64.buffer, adcValPtr, adcCount).slice();
              const imuTime = new Float64Array(M.HEAPF64.buffer, imuTimePtr, imuCount).slice();
              const imuGx = new Float64Array(M.HEAPF64.buffer, imuGxPtr, imuCount).slice();
              const imuGy = new Float64Array(M.HEAPF64.buffer, imuGyPtr, imuCount).slice();
              const imuGz = new Float64Array(M.HEAPF64.buffer, imuGzPtr, imuCount).slice();
              const imuAx = new Float64Array(M.HEAPF64.buffer, imuAxPtr, imuCount).slice();
              const imuAy = new Float64Array(M.HEAPF64.buffer, imuAyPtr, imuCount).slice();
              const imuAz = new Float64Array(M.HEAPF64.buffer, imuAzPtr, imuCount).slice();
              
              return {
                  adc: {
                      columns: [
                          { name: "timestamp_us", data: adcTime },
                          { name: "adc_piezo", data: adcVal }
                      ],
                      estimatedFreq: adcRateKhz * 1000
                  },
                  imu: {
                      columns: [
                          { name: "timestamp_us", data: imuTime },
                          { name: "gyro_x", data: imuGx },
                          { name: "gyro_y", data: imuGy },
                          { name: "gyro_z", data: imuGz },
                          { name: "accel_x", data: imuAx },
                          { name: "accel_y", data: imuAy },
                          { name: "accel_z", data: imuAz }
                      ],
                      estimatedFreq: 0
                  },
                  pagination: {
                      isTruncated: isTruncated,
                      loadedFrames: numFrames,
                      totalFrames: totalFramesInFile,
                      currentPage: 1,
                      totalPages: Math.ceil(totalFramesInFile / MAX_FRAMES)
                  }
              };
          } finally {
              // Free Wasm memory
              M._free(bufferPtr);
              M._free(adcTimePtr);
              M._free(adcValPtr);
              M._free(imuTimePtr);
              M._free(imuGxPtr);
              M._free(imuGyPtr);
              M._free(imuGzPtr);
              M._free(imuAxPtr);
              M._free(imuAyPtr);
              M._free(imuAzPtr);
              M._free(outAdcCountPtr);
              M._free(outImuCountPtr);
          }
      }
      
      // Wasm Anomaly Detection Function
      function calculateAnomaliesWasm(xData, thresholdUs, maxAnomalies = 10000) {
          if (!wasmReady) return [];
          
          const M = wasmModule;
          const length = xData.length;
          
          // Allocate memory
          const xDataPtr = M._malloc(length * 8);
          const indicesPtr = M._malloc(maxAnomalies * 4);
          const diffsPtr = M._malloc(maxAnomalies * 8);
          
          try {
              // Copy input
              M.HEAPF64.set(xData, xDataPtr >> 3);
              
              // Call Wasm
              const count = wasm_calculate_anomalies(
                  xDataPtr, length,
                  thresholdUs,
                  indicesPtr, diffsPtr,
                  maxAnomalies
              );
              
              // Read results
              const indices = new Uint32Array(M.HEAPU32.buffer, indicesPtr, count).slice();
              const diffs = new Float64Array(M.HEAPF64.buffer, diffsPtr, count).slice();
              
              // Format as anomaly objects
              const anomalies = [];
              const expectedInterval = 1000000 / (1000000 / thresholdUs * 2);  // Reverse threshold
              for (let i = 0; i < count; i++) {
                  anomalies.push({
                      t: xData[indices[i]],
                      diff: diffs[i],
                      expected: expectedInterval
                  });
              }
              
              return anomalies;
          } finally {
              M._free(xDataPtr);
              M._free(indicesPtr);
              M._free(diffsPtr);
          }
      }

      const WORKER_CODE = `
self.onmessage = function(e) {
    const msg = e.data;
    
    if (msg.type === 'parse') {
        // ... (existing CSV parse logic) ...
         try {
            const start = performance.now();
            const result = parseFullCSV(msg.text);
            if (!result) {
                 self.postMessage({ type: 'error', id: msg.id, message: 'File is empty or corrupt' });
                 return;
            }
            
            // Auto-detect frequency
            let freq = 0;
            const timeIdx = result.columns.findIndex(c => c.name.toLowerCase().includes("timestamp_us"));
            if (timeIdx !== -1) {
                freq = estimateFrequency(result.columns[timeIdx].data);
            }

            // Identify transferables (the Float64Arrays)
            const transferables = [];
            result.columns.forEach(c => {
                if (c.data && c.data.buffer) {
                    transferables.push(c.data.buffer);
                }
            });

            const end = performance.now();
            console.log(\`Worker: CSV Parsed in \${(end-start).toFixed(2)}ms\`);

            self.postMessage({ 
                type: 'parseComplete', 
                id: msg.id,
                columns: result.columns,
                estimatedFreq: freq,
                timeIdx: timeIdx,
                isBinary: false
            }, transferables);

        } catch (err) {
            console.error(err);
            self.postMessage({ type: 'error', id: msg.id, message: err.message });
        }
    }
    else if (msg.type === 'parseBinary') {
        try {
            const start = performance.now();
            const buffer = msg.buffer; // ArrayBuffer
            const result = parseBinaryLog(buffer);

            // Identify transferables
            const transferables = [];
            // ADC transferables
            result.adc.columns.forEach(c => transferables.push(c.data.buffer));
            // IMU transferables
            result.imu.columns.forEach(c => transferables.push(c.data.buffer));

            const end = performance.now();
            console.log(\`Worker: Binary Parsed in \${(end-start).toFixed(2)}ms\`);

            self.postMessage({
                type: 'parseBinaryComplete',
                id: msg.id,
                adc: result.adc,
                imu: result.imu,
                isBinary: true
            }, transferables);
            
        } catch(err) {
             console.error(err);
             self.postMessage({ type: 'error', id: msg.id, message: err.message });
        }
    }
    else if (msg.type === 'interpolate') {
        try {
            const result = interpolateToMasterTime(msg.srcX, msg.srcY, msg.masterX);
            self.postMessage({
                type: 'interpolateComplete',
                id: msg.id,
                result: result
            }, [result.buffer]); 
        } catch (err) {
            console.error(err);
            self.postMessage({ type: 'error', id: msg.id, message: err.message });
        }
    }
};

// --- Core Logic Functions ---

function parseBinaryLog(buffer) {
    const view = new DataView(buffer);
    const totalLen = buffer.byteLength;
    
    // Constants
    const HEADER_SIZE = 64;
    const FRAME_SIZE = 852;
    const LOG_CONFIG_MAGIC = 0xCAFE;
    const LOG_FRAME_MAGIC = 0x5A5A;
    const ADC_BLOCK_SIZE = 256;
    const IMU_BLOCK_SIZE = 20;

    // 1. Read Header
    if (totalLen < HEADER_SIZE) throw new Error("File too short for header");
    
    const magic = view.getUint16(0, true);
    if (magic !== LOG_CONFIG_MAGIC) throw new Error("Invalid Config Magic: " + magic.toString(16));

    const adcRateKhz = view.getUint16(4, true); // Offset 4: adc_sample_rate_khz
    // const adcBlockSize = view.getUint16(6, true); // Offset 6: adc_block_size
    
    const adcTickUs = 1000.0 / (adcRateKhz * 1000.0) * 1000000.0; // Wait, rate in kHz e.g. 100
    // If rate is 100 kHz, period is 10us.
    // 100 kHz = 100,000 Hz. Period = 1/100000 s = 10 us.
    // Logic: 1000 / adcRateKhz (in kHz) -> period in us.
    // e.g. 1000 / 100 = 10 us.
    const samplePeriodUs = 1000 / (adcRateKhz || 100); // Default to 100kHz if 0

    // 2. Count Frames to pre-allocate
    const numFrames = Math.floor((totalLen - HEADER_SIZE) / FRAME_SIZE);
    
    // Estimate total samples
    const maxAdcSamples = numFrames * ADC_BLOCK_SIZE;
    const maxImuSamples = numFrames * IMU_BLOCK_SIZE;

    // ADC Arrays
    const adcTime = new Float64Array(maxAdcSamples);
    const adcVal = new Float64Array(maxAdcSamples);
    
    // IMU Arrays
    const imuTime = new Float64Array(maxImuSamples);
    const imuGx = new Float64Array(maxImuSamples);
    const imuGy = new Float64Array(maxImuSamples);
    const imuGz = new Float64Array(maxImuSamples);
    const imuAx = new Float64Array(maxImuSamples);
    const imuAy = new Float64Array(maxImuSamples);
    const imuAz = new Float64Array(maxImuSamples);

    let adcIdx = 0;
    let imuIdx = 0;
    let offset = HEADER_SIZE;

    while (offset + FRAME_SIZE <= totalLen) {
        const fMagic = view.getUint16(offset, true);
        if (fMagic !== LOG_FRAME_MAGIC) {
            // console.warn("Invalid Frame Magic at " + offset);
            offset += 1; // Try to resync? Or just skip frame? 
            // For now, strict:
            offset += FRAME_SIZE; 
            continue; 
        }

        // Frame Layout:
        // 0: Magic (2)
        // 2: n_imu (2)
        // 4: adc_timestamp (4)
        // 8: adc_data (512) -> 256 * int16
        // 520: imu_data (320) -> 20 * 16 bytes
        // 840: mavlink (10)
        // 850: checksum (2)

        const nImu = view.getUint16(offset + 2, true);
        const adcBaseTime = view.getUint32(offset + 4, true);

        // --- Extract ADC ---
        const adcOffset = offset + 8;
        for (let i = 0; i < ADC_BLOCK_SIZE; i++) {
            // FIX: adcBaseTime is in TICKS. i is TICKS offset. 
            // Convert sum to microseconds.
            adcTime[adcIdx] = (adcBaseTime + i) * samplePeriodUs;
            adcVal[adcIdx] = view.getInt16(adcOffset + (i * 2), true);
            adcIdx++;
        }

        // --- Extract IMU ---
        const imuBaseOffset = offset + 520;
        const validImuCount = Math.min(nImu, IMU_BLOCK_SIZE);
        
        for (let i = 0; i < validImuCount; i++) {
            // IMU Sample: 12 bytes data, 4 bytes timestamp
            // data: gx, gy, gz, ax, ay, az (int16)
            const sOff = imuBaseOffset + (i * 16);
            
            const gx = view.getInt16(sOff + 0, true);
            const gy = view.getInt16(sOff + 2, true);
            const gz = view.getInt16(sOff + 4, true);
            const ax = view.getInt16(sOff + 6, true);
            const ay = view.getInt16(sOff + 8, true);
            const az = view.getInt16(sOff + 10, true);
            const ts = view.getUint32(sOff + 12, true);

            // FIX: Convert ticks to microseconds
            imuTime[imuIdx] = ts * samplePeriodUs;
            
            imuGx[imuIdx] = gx;
            imuGy[imuIdx] = gy;
            imuGz[imuIdx] = gz;
            imuAx[imuIdx] = ax;
            imuAy[imuIdx] = ay;
            imuAz[imuIdx] = az;
            
            imuIdx++;
        }

        offset += FRAME_SIZE;
    }

    return {
        adc: {
            columns: [
                { name: "timestamp_us", data: adcTime.subarray(0, adcIdx) },
                { name: "adc_piezo", data: adcVal.subarray(0, adcIdx) }
            ],
            estimatedFreq: adcRateKhz * 1000
        },
        imu: {
            columns: [
                { name: "timestamp_us", data: imuTime.subarray(0, imuIdx) },
                { name: "gyro_x", data: imuGx.subarray(0, imuIdx) },
                { name: "gyro_y", data: imuGy.subarray(0, imuIdx) },
                { name: "gyro_z", data: imuGz.subarray(0, imuIdx) },
                { name: "accel_x", data: imuAx.subarray(0, imuIdx) },
                { name: "accel_y", data: imuAy.subarray(0, imuIdx) },
                { name: "accel_z", data: imuAz.subarray(0, imuIdx) }
            ],
            estimatedFreq: 0 // Will auto-detect or is variable
        }
    };
}


// --- Core Logic Functions ---

function parseFullCSV(text) {
    const firstLineEnd = text.indexOf("\\n");
    if (firstLineEnd === -1) return null;

    const headerLine = text.substring(0, firstLineEnd).trim();
    const sep = headerLine.includes(";") ? ";" : ",";
    const headers = headerLine
      .split(sep)
      .map((h) => h.trim().replace(/^"|"$/g, ""));

    const numCols = headers.length;
    // Count actual newlines for accurate row estimation
    let newlineCount = 0;
    for (let i = 0; i < text.length; i++) {
        if (text.charCodeAt(i) === 10) newlineCount++;  // '\\n' = 10
    }
    const estRows = newlineCount + 1;
    const colData = headers.map(() => new Float64Array(estRows));

    let row = 0;
    let idx = firstLineEnd + 1;
    const len = text.length;

    while (idx < len) {
        let nextIdx = text.indexOf("\\n", idx);
        if (nextIdx === -1) nextIdx = len;

        const line = text.substring(idx, nextIdx).trim();
        if (line.length > 0) {
            const parts = line.split(sep);
            for (let c = 0; c < numCols; c++) {
                if (c < parts.length) {
                    colData[c][row] = parseFloat(parts[c]);
                }
            }
            row++;
        }
        idx = nextIdx + 1;
    }

    const finalColumns = headers.map((h, i) => ({
      name: h,
      data: colData[i].subarray(0, row),
    }));

    return { columns: finalColumns };
}

function estimateFrequency(xData) {
    const sampleCount = Math.min(1000, xData.length - 1);
    if (sampleCount <= 0) return 0;
    const totalTime = xData[sampleCount] - xData[0];  // microseconds
    if (totalTime <= 0) return 0;
    const avgInterval = totalTime / sampleCount;
    return Math.round(1000000 / avgInterval);  // Hz
}

function binarySearch(arr, t) {
    let lo = 0,
      hi = arr.length - 1;
    while (lo < hi) {
      const mid = (lo + hi + 1) >> 1;
      if (arr[mid] <= t) lo = mid;
      else hi = mid - 1;
    }
    return lo;
}

function interpolateToMasterTime(srcX, srcY, masterX) {
    const len = masterX.length;
    const result = new Float64Array(len);
    const srcLen = srcX.length;
    const srcFirst = srcX[0];
    const srcLast = srcX[srcLen - 1];

    for (let i = 0; i < len; i++) {
      const t = masterX[i];

      if (t < srcFirst) {
        result[i] = NaN;
        continue;
      }
      if (t > srcLast) {
        result[i] = NaN;
        continue;
      }

      // Find position using binary search
      const idx = binarySearch(srcX, t);

      if (idx >= srcLen - 1) {
        result[i] = srcY[srcLen - 1];
        continue;
      }

      const t0 = srcX[idx];
      if (t0 === t) {
        result[i] = srcY[idx];
        continue;
      }

      // Sample-and-hold (as per previous logic)
      result[i] = srcY[idx];
    }
    return result;
}
`;
      
      const blob = new Blob([WORKER_CODE], { type: "application/javascript" });
      const worker = new Worker(URL.createObjectURL(blob));
      
      const pendingRequests = new Map();

      worker.onmessage = (e) => {
          const msg = e.data;
          if (msg.type === 'error') {
              console.error("Worker error:", msg.message);
              const req = pendingRequests.get(msg.id);
              if (req) {
                  req.reject(msg.message);
                  pendingRequests.delete(msg.id);
              }
          }
          else if (msg.type === 'parseComplete') {
              const req = pendingRequests.get(msg.id);
              if (req && req.type === 'parse') {
                  req.resolve(msg);
                  pendingRequests.delete(msg.id);
              }
          }
          else if (msg.type === 'parseBinaryComplete') {
              const req = pendingRequests.get(msg.id);
              if (req && req.type === 'parseBinary') {
                  req.resolve(msg); // msg contains .adc and .imu
                  pendingRequests.delete(msg.id);
              }
          }
          else if (msg.type === 'interpolateComplete') {
              const req = pendingRequests.get(msg.id);
              if (req && req.type === 'interpolate') {
                  req.resolve(msg.result);
                  pendingRequests.delete(msg.id);
              }
          }
      };

      // Helper to generate IDs
      let msgIdCounter = 0;
      function callWorker(type, payload, transferables = []) {
          return new Promise((resolve, reject) => {
              const id = ++msgIdCounter;
              pendingRequests.set(id, { type, resolve, reject });
              worker.postMessage({ id, type, ...payload }, transferables);
          });
      }

      window.onload = () => {
        if (typeof uPlot === "undefined")
          alert("Помилка: uPlot.iife.min.js не знайдено!");
      };

      async function handleFiles(files) {
        if (!files.length) return;
        const btn = document.querySelector(".btn-primary");
        btn.innerText = "Читання...";
        btn.disabled = true;

        try {
            for (let i = 0; i < files.length; i++) {
                await processFile(files[i]);
            }
        } catch(e) {
            alert("Помилка при читанні: " + e);
        }

        btn.innerText = "+ Завантажити CSV";
        btn.disabled = false;
        document.getElementById("fileInput").value = "";
      }

      async function processFile(file) {
        const isBinary = file.name.toLowerCase().endsWith(".dat");

        const tempDs = {
          id: -1, 
          name: file.name,
          isLoading: true,
          isReady: false
        };
        datasets.push(tempDs);
        updateListUI();

        try {
            if (isBinary) {
                const buffer = await file.arrayBuffer();
                let result;
                
                // Use Wasm parser if available (faster), fallback to Worker
                if (wasmReady) {
                    console.log("Using Wasm parser for binary file...");
                    result = parseBinaryWithWasm(buffer);
                } else {
                    console.log("Wasm not ready, using Worker parser...");
                    result = await callWorker('parseBinary', { buffer }, [buffer]);
                }
                
                // Remove temp placeholder
                const idx = datasets.indexOf(tempDs);
                if (idx !== -1) datasets.splice(idx, 1);
                
                // Handle pagination for large files
                if (result.pagination && result.pagination.isTruncated) {
                    currentPageFile = file;  // Store file for lazy loading
                    showPaginationUI(result.pagination);
                } else {
                    hidePaginationUI();
                }
                
                // Add ADC Dataset (Auto-enable, skip render)
                if (result.adc) {
                     const adcDs = addDatasetFromWorkerResult(file.name + " (ADC)", result.adc, true, true);
                     if (result.pagination) adcDs.pagination = result.pagination;
                }
                // Add IMU Dataset - calculate derived columns first
                if (result.imu) {
                     calculateImuDerivedColumns(result.imu);
                     const imuDs = addDatasetFromWorkerResult(file.name + " (IMU)", result.imu, true, true);
                     if (result.pagination) imuDs.pagination = result.pagination;
                }
                // Render once after all datasets added
                renderChart();
            } 
            else {
                // CSV
                const text = await file.text();
                const result = await callWorker('parse', { text });
                
                // Remove temp placeholder
                const idx = datasets.indexOf(tempDs);
                if (idx !== -1) datasets.splice(idx, 1);
                
                if (!result || !result.columns) throw new Error("File empty or corrupt");
                
                // Check if this is IMU data CSV (has gyro/accel columns)
                const isImuCsv = file.name.toLowerCase().includes('imu') || 
                    result.columns.some(c => c.name.toLowerCase().includes('gyro') || c.name.toLowerCase().includes('accel'));
                
                if (isImuCsv) {
                    calculateImuDerivedColumns(result);
                }
                
                addDatasetFromWorkerResult(file.name, result, true);
            }
        } catch (err) {
            console.error(err);
             // Remove temp placeholder on error
            const idx = datasets.indexOf(tempDs);
            if (idx !== -1) datasets.splice(idx, 1);
            alert(`Error reading ${file.name}: ${err}`);
        }
        
        updateListUI();
      }

      function addDatasetFromWorkerResult(name, parsed, autoEnable = true, skipRender = false) {
        const newDs = {
          id: datasets.length,
          name: name,
          rawColumns: parsed.columns,
          config: { xIndex: -1, yIndices: [], expectedFreqHz: 0 },
          anomalies: [],
          isReady: false,
          isLoading: false
        };

        // Auto-detect config
        const timeIdx = parsed.timeIdx !== undefined ? parsed.timeIdx : 
                        parsed.columns.findIndex(c => c.name.toLowerCase().includes("timestamp") || c.name.toLowerCase().includes("time"));
        
        if (timeIdx !== -1) {
             newDs.config.xIndex = timeIdx;
             
             // Only set Y defaults if autoEnable is true
             if (autoEnable) {
                 // Prefer Gforce column for IMU data, otherwise use first non-time column
                 let yIdx = parsed.columns.findIndex(c => c.name === 'Gforce');
                 if (yIdx === -1) {
                     yIdx = parsed.columns.findIndex((_, i) => i !== timeIdx);
                 }
                 if (yIdx !== -1) {
                     newDs.config.yIndices = [yIdx];
                     newDs.isReady = true;
                 }
             }
             newDs.config.expectedFreqHz = parsed.estimatedFreq || 0;
        }

        datasets.push(newDs);
        
        // Render if ready (and master logic) - unless skipRender
        if (newDs.isReady && !skipRender) {
             calculateAnomalies(newDs);
             renderAnomalyTabs();
             renderChart();
        } else if (newDs.isReady) {
             // Still calculate anomalies even if skipping render
             calculateAnomalies(newDs);
             renderAnomalyTabs();
        }
        return newDs;
      }

      // === PAGINATION UI FUNCTIONS ===
      
      function showPaginationUI(pagination) {
          const banner = document.getElementById('warningBanner');
          const warningText = document.getElementById('warningText');
          const pageNav = document.getElementById('pageNav');
          const currentPageSpan = document.getElementById('currentPage');
          const totalPagesSpan = document.getElementById('totalPages');
          const pageSelect = document.getElementById('pageSelect');
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');
          
          // Update warning banner
          const totalSeconds = Math.round((pagination.totalFrames * 256) / 100000);  // approx seconds at 100kHz
          warningText.textContent = `Файл скорочено: показано ${pagination.loadedFrames.toLocaleString()} кадрів з ${pagination.totalFrames.toLocaleString()} (~${totalSeconds}с). Використовуйте навігацію для перегляду інших сторінок.`;
          banner.classList.add('visible');
          
          // Update page navigation
          currentPageSpan.textContent = pagination.currentPage;
          totalPagesSpan.textContent = pagination.totalPages;
          
          // Build page select dropdown
          pageSelect.innerHTML = '';
          for (let i = 1; i <= pagination.totalPages; i++) {
              const opt = document.createElement('option');
              opt.value = i;
              opt.textContent = `${i}`;
              if (i === pagination.currentPage) opt.selected = true;
              pageSelect.appendChild(opt);
          }
          
          // Update button states
          prevBtn.disabled = pagination.currentPage <= 1;
          nextBtn.disabled = pagination.currentPage >= pagination.totalPages;
          
          pageNav.classList.add('visible');
          
          // Store current pagination state
          activePaginatedDataset = pagination;
      }
      
      function hidePaginationUI() {
          document.getElementById('warningBanner').classList.remove('visible');
          document.getElementById('pageNav').classList.remove('visible');
          activePaginatedDataset = null;
          currentPageFile = null;
      }
      
      async function goToPage(delta) {
          if (!activePaginatedDataset || !currentPageFile) return;
          
          const newPage = activePaginatedDataset.currentPage + delta;
          if (newPage < 1 || newPage > activePaginatedDataset.totalPages) return;
          
          await loadPage(newPage);
      }
      
      async function goToPageDirect(pageNum) {
          const page = parseInt(pageNum);
          if (isNaN(page) || !activePaginatedDataset || !currentPageFile) return;
          if (page < 1 || page > activePaginatedDataset.totalPages) return;
          
          await loadPage(page);
      }
      
      async function loadPage(pageNum) {
          if (!currentPageFile || !wasmReady) return;
          
          const file = currentPageFile;
          const startFrame = (pageNum - 1) * FRAMES_PER_PAGE;
          const startOffset = HEADER_SIZE + (startFrame * FRAME_SIZE);
          
          // Calculate how many bytes we need to read
          const bytesToRead = Math.min(
              FRAMES_PER_PAGE * FRAME_SIZE,
              file.size - startOffset
          );
          
          if (bytesToRead <= 0) {
              alert('Неможливо завантажити сторінку: кінець файлу');
              return;
          }
          
          console.log(`Loading page ${pageNum}: offset=${startOffset}, bytes=${bytesToRead}`);
          
          // Show loading indicator
          const btn = document.querySelector(".btn-primary");
          btn.innerText = "Завантаження...";
          btn.disabled = true;
          
          try {
              // Read the header + the slice for this page
              const headerBuffer = await file.slice(0, HEADER_SIZE).arrayBuffer();
              const pageBuffer = await file.slice(startOffset, startOffset + bytesToRead).arrayBuffer();
              
              // Combine header with page data
              const combined = new Uint8Array(HEADER_SIZE + pageBuffer.byteLength);
              combined.set(new Uint8Array(headerBuffer), 0);
              combined.set(new Uint8Array(pageBuffer), HEADER_SIZE);
              
              // Parse this slice
              const result = parseBinaryWithWasm(combined.buffer);
              
              // Clear existing paginated datasets and add new ones
              const paginatedIdx = datasets.findIndex(ds => ds.pagination);
              if (paginatedIdx !== -1) {
                  // Remove old paginated datasets (both ADC and IMU from same file)
                  datasets = datasets.filter(ds => !ds.pagination);
              }
              
              // Update pagination state
              const newPagination = {
                  ...result.pagination,
                  currentPage: pageNum,
                  totalFrames: activePaginatedDataset.totalFrames,
                  totalPages: activePaginatedDataset.totalPages
              };
              
              // Add new datasets (skip render, will batch after)
              if (result.adc) {
                  const adcDs = addDatasetFromWorkerResult(file.name + " (ADC)", result.adc, true, true);
                  adcDs.pagination = newPagination;
              }
              if (result.imu) {
                  calculateImuDerivedColumns(result.imu);
                  const imuDs = addDatasetFromWorkerResult(file.name + " (IMU)", result.imu, true, true);
                  imuDs.pagination = newPagination;
              }
              
              // Render once after all datasets added
              renderChart();
              
              // Update UI
              showPaginationUI(newPagination);
              updateListUI();
              
          } catch (err) {
              console.error('Error loading page:', err);
              alert('Помилка завантаження сторінки: ' + err);
          } finally {
              btn.innerText = "+ Завантажити CSV";
              btn.disabled = false;
          }
      }

      // === UI: LIST & MODAL ===

      function updateListUI() {
        const list = document.getElementById("datasetList");
        list.innerHTML = "";

        datasets.forEach((ds, idx) => {
          const div = document.createElement("div");
          const isMaster = idx === getMasterIndex();
          
          let statusClass = "not-ready";
          if (ds.isLoading) statusClass = "loading";
          else if (ds.isReady) statusClass = isMaster ? "master" : "ready";

          let statusText = "";
          if (ds.isLoading) {
              statusText = "⏳ Обробка...";
          } else if (ds.isReady) {
              statusText = `Готово: X=${ds.rawColumns[ds.config.xIndex].name}, Y=[${ds.config.yIndices.length}]`;
          } else {
              statusText = "⚠️ Потрібне налаштування";
          }

          div.className = `dataset-item ${statusClass}`;
          div.innerHTML = `
                    <div class="ds-header">
                        <div style="display:flex; align-items:center; overflow:hidden;">
                            ${ds.isLoading ? '<span class="spinner"></span>' : ''}
                            <span class="ds-name" title="${ds.name}">${ds.name}</span>
                        </div>
                        ${!ds.isLoading && isMaster ? '<span style="font-size:9px; background:#007bff; padding:1px 3px; border-radius:3px;">MASTER</span>' : ""}
                    </div>
                    <div class="ds-status">${statusText}</div>
                    ${!ds.isLoading ? `
                    <div style="margin-top:8px; display:flex; justify-content:space-between;">
                        <button class="btn-icon ${ds.isReady ? "btn-neutral" : "btn-settings"}" onclick="openConfigModal(${idx})">⚙️ Налаштувати</button>
                        <div>
                             ${ds.isReady ? `<button class="btn-icon btn-fit" onclick="fitY(${idx})" title="Zoom Y">Fit Y</button>` : ""}
                             <button class="btn-icon btn-del" onclick="removeDataset(${idx})">✕</button>
                        </div>
                    </div>` : ''}
                `;
          list.appendChild(div);
        });
      }

      function openConfigModal(idx) {
        activeModalDatasetIndex = idx;
        const ds = datasets[idx];
        const list = document.getElementById("modalColList");
        list.innerHTML = "";

        const suggestX = ds.rawColumns.findIndex((c) =>
          c.name.toLowerCase().includes("timestamp_us"),
        );

        ds.rawColumns.forEach((col, cIdx) => {
          const isX =
            ds.config.xIndex === cIdx ||
            (ds.config.xIndex === -1 && cIdx === suggestX);
          const isY = ds.config.yIndices.includes(cIdx);

          const div = document.createElement("div");
          div.className = "col-item";
          div.innerHTML = `
                    <input type="radio" name="col_x" value="${cIdx}" ${isX ? "checked" : ""}>
                    <input type="checkbox" name="col_y" value="${cIdx}" ${isY ? "checked" : ""}>
                    <span>${col.name}</span>
                `;
          list.appendChild(div);
        });

        // Set frequency field - use existing value or auto-detect
        const freqInput = document.getElementById("modalFreq");
        if (ds.config.expectedFreqHz > 0) {
          freqInput.value = ds.config.expectedFreqHz;
        } else if (suggestX !== -1) {
          freqInput.value = estimateFrequency(ds.rawColumns[suggestX].data);
        } else {
          freqInput.value = "";
        }

        // Show/hide IMU settings section based on dataset type
        const isImuDataset = ds.name.toLowerCase().includes('imu') || 
            ds.rawColumns.some(c => c.name.toLowerCase().includes('gyro') || c.name.toLowerCase().includes('accel'));
        const imuSection = document.getElementById('imuSettingsSection');
        imuSection.style.display = isImuDataset ? 'block' : 'none';
        
        if (isImuDataset) {
            // Set current values
            document.getElementById('modalAccelRange').value = imuSettings.accelRangeG;
            document.getElementById('modalGyroRange').value = imuSettings.gyroRangeDps;
        }

        document.getElementById("configModal").style.display = "flex";
      }

      function closeModal() {
        document.getElementById("configModal").style.display = "none";
        activeModalDatasetIndex = -1;
      }

      function applyModalConfig() {
        if (activeModalDatasetIndex === -1) return;

        const list = document.getElementById("modalColList");
        const radioX = list.querySelector('input[name="col_x"]:checked');
        const checksY = list.querySelectorAll('input[name="col_y"]:checked');

        if (!radioX) return alert("Виберіть колонку для осі X!");
        if (checksY.length === 0)
          return alert("Виберіть хоча б одну колонку даних (Y)!");

        const xIdx = parseInt(radioX.value);
        const yIdxs = Array.from(checksY).map((cb) => parseInt(cb.value));

        const ds = datasets[activeModalDatasetIndex];
        ds.config.xIndex = xIdx;
        ds.config.yIndices = yIdxs;

        // Get frequency from input
        const freqInput = document.getElementById("modalFreq");
        ds.config.expectedFreqHz = parseInt(freqInput.value) || 0;
        ds.isReady = true;

        // Check if IMU settings changed and recalculate derived columns
        const isImuDataset = ds.name.toLowerCase().includes('imu') || 
            ds.rawColumns.some(c => c.name.toLowerCase().includes('gyro') || c.name.toLowerCase().includes('accel'));
        
        if (isImuDataset) {
            const newAccelRange = parseInt(document.getElementById('modalAccelRange').value);
            const newGyroRange = parseInt(document.getElementById('modalGyroRange').value);
            
            // Check if settings changed
            if (newAccelRange !== imuSettings.accelRangeG || newGyroRange !== imuSettings.gyroRangeDps) {
                imuSettings.accelRangeG = newAccelRange;
                imuSettings.gyroRangeDps = newGyroRange;
                
                // Remove old Gforce and GyroS columns
                ds.rawColumns = ds.rawColumns.filter(c => c.name !== 'Gforce' && c.name !== 'GyroS');
                
                // Recalculate derived columns
                const imuData = { columns: ds.rawColumns };
                calculateImuDerivedColumns(imuData);
                ds.rawColumns = imuData.columns;
                
                console.log(`Recalculated IMU data with Accel=${newAccelRange}g, Gyro=${newGyroRange}dps`);
            }
        }

        // Calculate anomalies for this dataset
        calculateAnomalies(ds);

        closeModal();
        updateListUI();
        renderAnomalyTabs(); // Update anomaly tabs
        renderChart();
      }

      function removeDataset(idx) {
        // Reset active tab if it was the deleted dataset
        if (activeAnomalyTab === idx) {
          activeAnomalyTab = -1;
        } else if (activeAnomalyTab > idx) {
          activeAnomalyTab--; // Adjust index for shifted datasets
        }

        // Explicitly clear data arrays to help GC
        const ds = datasets[idx];
        if (ds) {
          if (ds.rawColumns) {
            ds.rawColumns.forEach(col => {
              col.data = null;
            });
            ds.rawColumns = null;
          }
          ds.anomalies = null;
          ds.config = null;
        }

        datasets.splice(idx, 1);
        
        // Force garbage collection hint
        if (typeof gc === 'function') gc();
        
        updateListUI();
        renderAnomalyTabs();
        renderChart();
      }

      // === LOGIC UTILS ===

      function getMasterIndex() {
        return datasets.findIndex((d) => d.isReady);
      }

      function countReadyDatasets() {
        return datasets.filter((d) => d.isReady).length;
      }

      // Estimate frequency from first 1000 samples
      function estimateFrequency(xData) {
        const sampleCount = Math.min(1000, xData.length - 1);
        if (sampleCount <= 0) return 0;
        const totalTime = xData[sampleCount] - xData[0]; // microseconds
        if (totalTime <= 0) return 0;
        const avgInterval = totalTime / sampleCount;
        return Math.round(1000000 / avgInterval); // Hz
      }

      // Calculate anomalies for a dataset based on expected frequency
      function calculateAnomalies(ds) {
        ds.anomalies = [];
        if (!ds.isReady || ds.config.expectedFreqHz <= 0) return;

        const xData = ds.rawColumns[ds.config.xIndex].data;
        const expectedInterval = 1000000 / ds.config.expectedFreqHz; // μs
        const threshold = expectedInterval * 2; // 200% = 2x expected interval

        // Use Wasm if available for faster processing
        if (wasmReady && xData.length > 1000) {
            console.log(`Using Wasm for anomaly detection (${xData.length} samples)...`);
            const start = performance.now();
            ds.anomalies = calculateAnomaliesWasm(xData, threshold);
            const end = performance.now();
            console.log(`Wasm anomaly detection: ${(end-start).toFixed(2)}ms, found ${ds.anomalies.length} anomalies`);
            return;
        }

        // Fallback to JS implementation
        for (let i = 1; i < xData.length; i++) {
          const diff = xData[i] - xData[i - 1];
          if (diff > threshold) {
            ds.anomalies.push({
              t: xData[i],
              diff: diff,
              expected: expectedInterval,
            });
          }
        }
      }

      // Render anomaly tabs for all ready datasets
      function renderAnomalyTabs() {
        const tabsContainer = document.getElementById("jumpTabs");
        const list = document.getElementById("jumpList");
        tabsContainer.innerHTML = "";
        list.innerHTML = "";

        const readyDatasets = datasets.filter((ds) => ds.isReady);

        if (readyDatasets.length === 0) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Завантажте файли</span>';
          return;
        }

        // Calculate anomalies for all datasets if not done yet
        readyDatasets.forEach((ds) => {
          if (ds.anomalies.length === 0 && ds.config.expectedFreqHz > 0) {
            calculateAnomalies(ds);
          }
        });

        // Create tabs
        readyDatasets.forEach((ds, idx) => {
          const dsIdx = datasets.indexOf(ds);
          const tab = document.createElement("button");
          tab.className =
            "jump-tab" + (activeAnomalyTab === dsIdx ? " active" : "");

          const count = ds.anomalies.length;
          const shortName =
            ds.name.length > 15 ? ds.name.substring(0, 12) + "..." : ds.name;
          tab.innerHTML = `${shortName}<span class="count">${count > 0 ? `(${count})` : "(0)"}</span>`;
          tab.onclick = () => selectAnomalyTab(dsIdx);
          tabsContainer.appendChild(tab);

          // Auto-select first tab if none selected
          if (activeAnomalyTab === -1 && idx === 0) {
            activeAnomalyTab = dsIdx;
            tab.classList.add("active");
          }
        });

        // Render anomalies for active tab
        renderAnomaliesForTab();
      }

      function selectAnomalyTab(dsIdx) {
        activeAnomalyTab = dsIdx;
        // Update tab styles
        document
          .querySelectorAll(".jump-tab")
          .forEach((tab) => tab.classList.remove("active"));
        const tabs = document.querySelectorAll(".jump-tab");
        const readyDatasets = datasets.filter((ds) => ds.isReady);
        const tabIdx = readyDatasets.findIndex(
          (ds) => datasets.indexOf(ds) === dsIdx,
        );
        if (tabIdx >= 0 && tabs[tabIdx]) tabs[tabIdx].classList.add("active");
        renderAnomaliesForTab();
      }

      function renderAnomaliesForTab() {
        const list = document.getElementById("jumpList");
        list.innerHTML = "";

        if (activeAnomalyTab === -1 || !datasets[activeAnomalyTab]) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Виберіть датасет</span>';
          return;
        }

        const ds = datasets[activeAnomalyTab];
        const anomalies = ds.anomalies;

        if (!ds.config.expectedFreqHz || ds.config.expectedFreqHz <= 0) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Вкажіть частоту в налаштуваннях</span>';
          return;
        }

        if (anomalies.length === 0) {
          list.innerHTML =
            '<span style="color:#2f9e44; padding:5px;">✓ Норма (немає аномалій)</span>';
          return;
        }

        const limit = Math.min(anomalies.length, 300);
        anomalies.slice(0, limit).forEach((a) => {
          const el = document.createElement("span");
          el.className = "jump-item";
          el.innerHTML = `T:${a.t} <span class="jump-bad">Δ${a.diff.toFixed(0)}</span> (${(a.diff / a.expected).toFixed(1)}x)`;
          el.onclick = () => zoomTo(a.t);
          list.appendChild(el);
        });
        if (anomalies.length > limit) {
          list.innerHTML += `<span style="color:#777; padding:5px;">... ще ${anomalies.length - limit}</span>`;
        }
      }

      // Legacy function - now just calls renderAnomalyTabs
      function recalcJumps() {
        renderAnomalyTabs();
      }

      function renderJumpsList() {
        renderAnomaliesForTab();
      }

      // === CHART RENDERING ===

      // Store reference to current chart data for cleanup
      let currentChartData = null;

      async function renderChart() {
        const div = document.getElementById("chart");
        
        // Clean up previous chart data
        if (currentChartData) {
          for (let i = 0; i < currentChartData.length; i++) {
            currentChartData[i] = null;
          }
          currentChartData = null;
        }
        
        if (uplot) {
          uplot.destroy();
          uplot = null;
        }
        div.innerHTML = "";

        const mIdx = getMasterIndex();
        if (mIdx === -1) return;

        const masterDs = datasets[mIdx];
        const masterX = masterDs.rawColumns[masterDs.config.xIndex].data;

        const chartData = [masterX];
        const series = [{}];
        const scales = { x: { time: false } };
        const axes = [
          { scale: "x" }, // X axis
        ];

        let globalSeriesCounter = 0;
        
        // Prepare list of series to render and interpolation tasks
        const seriesInfo = [];
        const interpolationPromises = [];

        datasets.forEach((ds, dsIdx) => {
          if (!ds.isReady) return;

          const dsX = ds.rawColumns[ds.config.xIndex].data;
          const isMaster = ds === masterDs;

          ds.config.yIndices.forEach((yIdx) => {
            const colName = ds.rawColumns[yIdx].name;
            const yData = ds.rawColumns[yIdx].data;
            const scaleName = globalSeriesCounter === 0 ? "y" : `y${globalSeriesCounter + 1}`;
            
            // Collect metadata for later use
            seriesInfo.push({
                ds,
                colName,
                yData,
                scaleName,
                isMaster,
                strokeColor: globalSeriesCounter === 0 ? "#00ff00" : PALETTE[(globalSeriesCounter - 1) % PALETTE.length],
                globalIndex: globalSeriesCounter
            });
            
            if (isMaster) {
                // No interpolation needed
                interpolationPromises.push(Promise.resolve(yData));
            } else {
                // Offload interpolation to worker
                interpolationPromises.push(callWorker('interpolate', {
                    srcX: dsX,
                    srcY: yData,
                    masterX: masterX
                }));
            }
            
            globalSeriesCounter++;
          });
        });

        // Wait for all interpolations to finish
        let interpolatedResults;
        try {
            interpolatedResults = await Promise.all(interpolationPromises);
        } catch (e) {
            console.error("Interpolation failed", e);
            alert("Interpolation error: " + e);
            return;
        }

        // Build chart configuration and data
        seriesInfo.forEach((info, idx) => {
            const { ds, colName, inputs, scaleName, strokeColor, globalIndex } = info;
            const yData = interpolatedResults[idx]; // Result from worker or direct pass-through

             // Calculate min/max for this specific column (using the data we are about to plot)
             // Note: if interpolated, we use the interpolated data for range which is correct for view
             // Optimization: Use worker to calc min/max too? For now, main thread is fine for this loop.
            let colMin = Infinity, colMax = -Infinity;
            for (let v of yData) {
              if (!isNaN(v)) {
                if (v < colMin) colMin = v;
                if (v > colMax) colMax = v;
              }
            }
            const range = colMax - colMin || 1;

            scales[scaleName] = {
              auto: true,
              range: [colMin - range * 0.05, colMax + range * 0.05],
            };

            axes.push({
              scale: scaleName,
              side: globalIndex === 0 ? 3 : 1,
              grid: { show: globalIndex === 0 },
              stroke: strokeColor,
              ticks: { stroke: strokeColor },
              label: `${ds.name} (${colName})`,
              labelSize: 30,
            });

            // Add custom path builder with downsampling for large datasets
            series.push({
              label: `${ds.name} (${colName})`,
              stroke: strokeColor,
              width: 1,
              scale: scaleName,
              points: { show: false },
              paths: downsamplePath,  // Use custom downsampling path builder
            });
            
            chartData.push(yData);
        });

        const opts = {
          width: div.clientWidth,
          height: div.clientHeight,
          series: series,
          scales: scales,
          axes: axes,
          cursor: { drag: { x: true, y: true, uni: 50 } },
          legend: { show: false },
          hooks: { setLegend: [updateHoverInfo] },
          plugins: [wheelZoomPlugin({ factor: 0.75 }), middleClickPanPlugin()],
        };

        uplot = new uPlot(opts, chartData, div);
        currentChartData = chartData;  // Store reference for cleanup
        document.getElementById("dispValues").innerHTML = "";
      }
      
      // Clear all datasets and free memory
      function clearAllDatasets() {
        console.log("Clearing all datasets...");
        
        // Clean up chart
        if (currentChartData) {
          for (let i = 0; i < currentChartData.length; i++) {
            currentChartData[i] = null;
          }
          currentChartData = null;
        }
        
        if (uplot) {
          uplot.destroy();
          uplot = null;
        }
        
        // Clean up all datasets
        datasets.forEach(ds => {
          if (ds && ds.rawColumns) {
            ds.rawColumns.forEach(col => {
              col.data = null;
            });
            ds.rawColumns = null;
          }
          if (ds) {
            ds.anomalies = null;
            ds.config = null;
          }
        });
        
        datasets.length = 0;
        activeAnomalyTab = -1;
        
        updateListUI();
        renderAnomalyTabs();
        document.getElementById("chart").innerHTML = "";
        document.getElementById("dispValues").innerHTML = "";
        
        console.log("Memory cleared");
      }
      
      // Custom downsampling path builder using min/max decimation
      // This reduces the number of points drawn while preserving visual peaks
      function downsamplePath(u, seriesIdx, idx0, idx1, extendGap, buildClip) {
        const s = u.series[seriesIdx];
        const xdata = u.data[0];
        const ydata = u.data[seriesIdx];
        const scaleX = u.scales.x;
        const scaleY = u.scales[s.scale];
        
        // Target ~2000 points max for smooth rendering
        const MAX_POINTS = 2000;
        const totalPoints = idx1 - idx0;
        
        // If data is small enough, use default path builder
        if (totalPoints <= MAX_POINTS) {
          return uPlot.paths.linear()(u, seriesIdx, idx0, idx1, extendGap, buildClip);
        }
        
        console.log(`Downsampling ${totalPoints} points to ~${MAX_POINTS}`);
        
        const bucketSize = Math.ceil(totalPoints / MAX_POINTS);
        const path = new Path2D();
        
        let first = true;
        let prevX = null;
        
        for (let bucket = 0; bucket < MAX_POINTS && (idx0 + bucket * bucketSize) < idx1; bucket++) {
          const bucketStart = idx0 + bucket * bucketSize;
          const bucketEnd = Math.min(bucketStart + bucketSize, idx1);
          
          // Find min and max in bucket
          let minVal = Infinity, maxVal = -Infinity;
          let minIdx = bucketStart, maxIdx = bucketStart;
          
          for (let i = bucketStart; i < bucketEnd; i++) {
            const val = ydata[i];
            if (val == null || isNaN(val)) continue;
            if (val < minVal) { minVal = val; minIdx = i; }
            if (val > maxVal) { maxVal = val; maxIdx = i; }
          }
          
          if (minVal === Infinity) continue;
          
          // Draw both min and max points (in order of appearance)
          const points = minIdx < maxIdx 
            ? [[minIdx, minVal], [maxIdx, maxVal]]
            : [[maxIdx, maxVal], [minIdx, minVal]];
          
          for (const [idx, val] of points) {
            const x = u.valToPos(xdata[idx], 'x', true);
            const y = u.valToPos(val, s.scale, true);
            
            if (first) {
              path.moveTo(x, y);
              first = false;
            } else {
              path.lineTo(x, y);
            }
            prevX = x;
          }
        }
        
        return {
          stroke: path,
          fill: null,
          clip: null,
          flags: 0
        };
      }

      function fitY(dsIndex) {
        if (!uplot) return;
        const ds = datasets[dsIndex];

        // Count which series indices belong to this dataset
        let seriesStartIdx = 0;
        for (let i = 0; i < dsIndex; i++) {
          if (datasets[i].isReady) {
            seriesStartIdx += datasets[i].config.yIndices.length;
          }
        }

        // Fit each column's scale
        ds.config.yIndices.forEach((yIdx, colIdx) => {
          const arr = ds.rawColumns[yIdx].data;
          let gMin = Infinity,
            gMax = -Infinity;

          for (let v of arr) {
            if (!isNaN(v)) {
              if (v < gMin) gMin = v;
              if (v > gMax) gMax = v;
            }
          }

          if (gMin !== Infinity) {
            const range = gMax - gMin || 1;
            const seriesIdx = seriesStartIdx + colIdx;
            const scaleName = seriesIdx === 0 ? "y" : `y${seriesIdx + 1}`;

            uplot.setScale(scaleName, {
              min: gMin - range * 0.05,
              max: gMax + range * 0.05,
            });
          }
        });
      }

      function zoomTo(time) {
        if (!uplot) return;
        uplot.setScale("x", { min: time - 5000, max: time + 5000 });
      }

      function updateHoverInfo(u) {
        const idx = u.cursor.idx;
        const tEl = document.getElementById("dispTime");
        const vContainer = document.getElementById("dispValues");

        if (idx === null || idx === undefined) {
          tEl.innerText = "-";
          vContainer.innerHTML = "";
        } else {
          tEl.innerText = u.data[0][idx];

          let html = "";
          for (let i = 1; i < u.series.length; i++) {
            const val = u.data[i][idx];
            const color = u.series[i]._stroke;
            const label = u.series[i].label;
            const shortName =
              label.length > 20 ? label.substring(0, 18) + ".." : label;

            html += `<div style="color:${color}; font-size:12px;">
                        <span style="opacity:0.7">${shortName}:</span> 
                        <b>${isNaN(val) ? "-" : val}</b>
                    </div>`;
          }
          vContainer.innerHTML = html;
        }
      }

      // === PLUGINS ===
      function wheelZoomPlugin(opts) {
        let factor = opts.factor || 0.75;
        return {
          hooks: {
            ready: (u) => {
              u.over.addEventListener("wheel", (e) => {
                e.preventDefault();
                let { left } = u.cursor;
                let leftPct = left / u.bbox.width;
                let xVal = u.posToVal(left, "x");
                let xMin = u.scales.x.min;
                let xMax = u.scales.x.max;
                let xRange = xMax - xMin;
                if (e.deltaY < 0)
                  u.setScale("x", {
                    min: xVal - leftPct * (xRange * factor),
                    max: xVal + (1 - leftPct) * (xRange * factor),
                  });
                else
                  u.setScale("x", {
                    min: xVal - leftPct * (xRange / factor),
                    max: xVal + (1 - leftPct) * (xRange / factor),
                  });
              });
            },
          },
        };
      }
      function middleClickPanPlugin() {
        return {
          hooks: {
            init: (u) => {
              let isPanning = false,
                startX = 0,
                initMin = 0,
                initMax = 0;
              u.over.addEventListener("mousedown", (e) => {
                if (e.button === 1) {
                  e.preventDefault();
                  isPanning = true;
                  startX = e.clientX;
                  initMin = u.scales.x.min;
                  initMax = u.scales.x.max;
                  document.body.style.cursor = "grabbing";
                }
              });
              document.addEventListener("mousemove", (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const dxPx = startX - e.clientX;
                const xRange = initMax - initMin;
                const dxVal = dxPx / (u.bbox.width / xRange);
                u.setScale("x", { min: initMin + dxVal, max: initMax + dxVal });
              });
              document.addEventListener("mouseup", (e) => {
                if (e.button === 1) {
                  isPanning = false;
                  document.body.style.cursor = "default";
                }
              });
            },
          },
        };
      }

      window.addEventListener("resize", () => {
        if (uplot)
          uplot.setSize({
            width: document.getElementById("chart").clientWidth,
            height: document.getElementById("chart").clientHeight,
          });
      });
    </script>
  </body>
</html>
