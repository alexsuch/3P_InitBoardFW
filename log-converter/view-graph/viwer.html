<!doctype html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <title>Pro CSV Viewer v6 (High Contrast Selection)</title>
    <link rel="stylesheet" href="uPlot.min.css" />
    <script src="uPlot.iife.min.js"></script>

    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #121212;
        color: #eee;
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
      }


      /* --- LOADING SPINNER --- */
      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #555;
        border-top: 2px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 5px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* --- ВІЗУАЛІЗАЦІЯ ВИДІЛЕННЯ (НОВЕ) --- */
      .u-select {
        background: rgba(0, 123, 255, 0.3) !important;
        border: 1px solid #007bff !important;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      }

      /* --- SIDEBAR --- */
      .sidebar {
        width: 300px;
        background: #1e1e1e;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        padding: 15px;
        box-sizing: border-box;
        flex-shrink: 0;
        overflow-y: auto;
      }

      .logo {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #fff;
      }
      .logo span {
        color: #007bff;
      }

      .btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        color: white;
        transition: 0.2s;
      }
      .btn-primary {
        background: #007bff;
      }
      .btn-primary:hover {
        background: #0056b3;
      }

      .btn-icon {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 2px;
        cursor: pointer;
        border: none;
        border-radius: 3px;
        color: white;
      }
      .btn-settings {
        background: #f59f00;
      }
      .btn-neutral {
        background: #555;
      }
      .btn-fit {
        background: #2f9e44;
      }
      .btn-del {
        background: #e03131;
      }

      .dataset-list {
        margin-top: 20px;
        border-top: 1px solid #333;
        padding-top: 10px;
      }
      .dataset-item {
        background: #252525;
        border: 1px solid #333;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 8px;
        position: relative;
      }
      .dataset-item.not-ready {
        border-left: 3px solid #f59f00;
        opacity: 0.9;
      }
      .dataset-item.ready {
        border-left: 3px solid #2f9e44;
      }
      .dataset-item.master {
        border-left: 3px solid #007bff;
      }
      .dataset-item.loading {
        border-left: 3px solid #777;
        opacity: 0.7;
      }

      .ds-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }
      .ds-name {
        font-size: 13px;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 140px;
      }
      .ds-status {
        font-size: 10px;
        color: #aaa;
        margin-top: 2px;
      }

      /* --- MAIN AREA --- */
      .main-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #000;
        overflow: hidden;
        position: relative;
      }

      #hoverInfo {
        height: 30px;
        background: #111;
        border-bottom: 1px solid #333;
        display: flex;
        gap: 20px;
        align-items: center;
        padding: 0 10px;
        font-family: monospace;
        font-size: 14px;
        color: #aaa;
        flex-shrink: 0;
      }
      #chart {
        flex: 1;
        width: 100%;
        height: 100%;
        position: relative;
        cursor: crosshair;
      }

      .jump-panel {
        height: 150px;
        background: #1a1a1a;
        border-top: 1px solid #333;
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
      }
      .jump-tabs {
        display: flex;
        gap: 2px;
        padding: 5px;
        background: #222;
        flex-wrap: wrap;
      }
      .jump-tab {
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
        border-radius: 3px 3px 0 0;
        background: #333;
        color: #888;
        border: none;
      }
      .jump-tab:hover {
        background: #444;
        color: #fff;
      }
      .jump-tab.active {
        background: #1a1a1a;
        color: #4dabf7;
        font-weight: bold;
      }
      .jump-tab .count {
        color: #ff6b6b;
        margin-left: 4px;
      }
      .jump-list {
        overflow-y: auto;
        flex: 1;
        padding: 5px;
      }
      .jump-item {
        display: inline-block;
        padding: 4px 8px;
        margin: 2px;
        background: #333;
        border-radius: 3px;
        font-size: 12px;
        font-family: monospace;
        cursor: pointer;
      }
      .jump-bad {
        color: #ff6b6b;
        font-weight: bold;
      }

      /* --- MODAL --- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        display: none;
        justify-content: center;
        align-items: center;
      }
      .modal {
        background: #252525;
        padding: 20px;
        border-radius: 8px;
        width: 400px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        border: 1px solid #444;
      }
      .modal h3 {
        margin-top: 0;
        margin-bottom: 15px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      .col-list {
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 15px;
        border: 1px solid #333;
        padding: 5px;
        background: #1a1a1a;
      }
      .col-item {
        display: grid;
        grid-template-columns: 30px 30px 1fr;
        gap: 10px;
        padding: 5px;
        border-bottom: 1px solid #333;
        align-items: center;
        font-size: 13px;
      }
      .col-header {
        display: grid;
        grid-template-columns: 30px 30px 1fr;
        gap: 10px;
        padding: 5px;
        font-weight: bold;
        font-size: 12px;
        color: #aaa;
        border-bottom: 1px solid #555;
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
      #fileInput {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="modal-overlay" id="configModal">
      <div class="modal">
        <h3>Налаштування колонок</h3>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 10px">
          Виберіть <b>одну</b> колонку для часу (X) і
          <b>будь-яку кількість</b> для даних (Y).
        </div>

        <div class="col-header">
          <span>X</span>
          <span>Y</span>
          <span>Назва колонки</span>
        </div>
        <div class="col-list" id="modalColList"></div>

        <div
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
          "
        >
          <label
            style="
              font-size: 12px;
              color: #aaa;
              display: block;
              margin-bottom: 5px;
            "
          >
            Очікувана частота (Hz) - для визначення аномалій:
          </label>
          <input
            type="number"
            id="modalFreq"
            placeholder="напр. 100000"
            style="
              width: 100%;
              background: #2c2c2c;
              border: 1px solid #444;
              color: white;
              padding: 8px;
              border-radius: 4px;
            "
          />
        </div>

        <div class="modal-footer">
          <button
            class="btn btn-del"
            style="width: auto"
            onclick="closeModal()"
          >
            Скасувати
          </button>
          <button
            class="btn btn-primary"
            style="width: auto"
            onclick="applyModalConfig()"
          >
            Застосувати
          </button>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="logo">⚡ CSV <span>Pro v6</span></div>

      <button
        class="btn btn-primary"
        onclick="document.getElementById('fileInput').click()"
      >
        + Завантажити CSV
      </button>
      <input
        type="file"
        id="fileInput"
        accept=".csv"
        multiple
        onchange="handleFiles(this.files)"
      />

      <div class="dataset-list" id="datasetList"></div>
    </div>

    <div class="main-area">
      <div id="hoverInfo">
        <div>TIME: <span id="dispTime" style="color: #4dabf7">-</span></div>
        <div id="dispValues" style="display: flex; gap: 15px"></div>
      </div>

      <div id="chart"></div>

      <div class="jump-panel">
        <div class="jump-tabs" id="jumpTabs"></div>
        <div class="jump-list" id="jumpList"></div>
      </div>
    </div>

    <script>
      // === GLOBAL STATE ===
      const PALETTE = [
        "#ff00ff",
        "#00ccff",
        "#ffff00",
        "#ff6b6b",
        "#ffa500",
        "#00ffaa",
        "#aa00ff",
        "#ffffff",
        "#995500",
        "#ff0088",
      ];

      let datasets = [];
      let activeModalDatasetIndex = -1;
      let uplot = null;
      let jumps = [];
      let activeAnomalyTab = -1;
      
      // Worker setup
      
      const WORKER_CODE = `
self.onmessage = function(e) {
    const msg = e.data;
    
    if (msg.type === 'parse') {
        try {
            const start = performance.now();
            const result = parseFullCSV(msg.text);
            if (!result) {
                 self.postMessage({ type: 'error', id: msg.id, message: 'File is empty or corrupt' });
                 return;
            }
            
            // Auto-detect frequency
            let freq = 0;
            const timeIdx = result.columns.findIndex(c => c.name.toLowerCase().includes("timestamp_us"));
            if (timeIdx !== -1) {
                freq = estimateFrequency(result.columns[timeIdx].data);
            }

            // Identify transferables (the Float64Arrays)
            const transferables = [];
            result.columns.forEach(c => {
                if (c.data && c.data.buffer) {
                    transferables.push(c.data.buffer);
                }
            });

            const end = performance.now();
            console.log(\`Worker: Parsed in \${(end-start).toFixed(2)}ms\`);

            self.postMessage({ 
                type: 'parseComplete', 
                id: msg.id,
                columns: result.columns,
                estimatedFreq: freq,
                timeIdx: timeIdx
            }, transferables);

        } catch (err) {
            console.error(err);
            self.postMessage({ type: 'error', id: msg.id, message: err.message });
        }
    }
    else if (msg.type === 'interpolate') {
        try {
            // msg: { id, srcX, srcY, masterX }
            // inputs are copied (structured clone) so we don't destroy main thread data
            const result = interpolateToMasterTime(msg.srcX, msg.srcY, msg.masterX);
            
            self.postMessage({
                type: 'interpolateComplete',
                id: msg.id,
                result: result
            }, [result.buffer]); // Transfer output back to avoid copy
        } catch (err) {
            console.error(err);
            self.postMessage({ type: 'error', id: msg.id, message: err.message });
        }
    }
};

// --- Core Logic Functions ---

function parseFullCSV(text) {
    const firstLineEnd = text.indexOf("\\n");
    if (firstLineEnd === -1) return null;

    const headerLine = text.substring(0, firstLineEnd).trim();
    const sep = headerLine.includes(";") ? ";" : ",";
    const headers = headerLine
      .split(sep)
      .map((h) => h.trim().replace(/^"|"$/g, ""));

    const numCols = headers.length;
    // Count actual newlines for accurate row estimation
    let newlineCount = 0;
    for (let i = 0; i < text.length; i++) {
        if (text.charCodeAt(i) === 10) newlineCount++;  // '\\n' = 10
    }
    const estRows = newlineCount + 1;
    const colData = headers.map(() => new Float64Array(estRows));

    let row = 0;
    let idx = firstLineEnd + 1;
    const len = text.length;

    while (idx < len) {
        let nextIdx = text.indexOf("\\n", idx);
        if (nextIdx === -1) nextIdx = len;

        const line = text.substring(idx, nextIdx).trim();
        if (line.length > 0) {
            const parts = line.split(sep);
            for (let c = 0; c < numCols; c++) {
                if (c < parts.length) {
                    colData[c][row] = parseFloat(parts[c]);
                }
            }
            row++;
        }
        idx = nextIdx + 1;
    }

    const finalColumns = headers.map((h, i) => ({
      name: h,
      data: colData[i].subarray(0, row),
    }));

    return { columns: finalColumns };
}

function estimateFrequency(xData) {
    const sampleCount = Math.min(1000, xData.length - 1);
    if (sampleCount <= 0) return 0;
    const totalTime = xData[sampleCount] - xData[0];  // microseconds
    if (totalTime <= 0) return 0;
    const avgInterval = totalTime / sampleCount;
    return Math.round(1000000 / avgInterval);  // Hz
}

function binarySearch(arr, t) {
    let lo = 0,
      hi = arr.length - 1;
    while (lo < hi) {
      const mid = (lo + hi + 1) >> 1;
      if (arr[mid] <= t) lo = mid;
      else hi = mid - 1;
    }
    return lo;
}

function interpolateToMasterTime(srcX, srcY, masterX) {
    const len = masterX.length;
    const result = new Float64Array(len);
    const srcLen = srcX.length;
    const srcFirst = srcX[0];
    const srcLast = srcX[srcLen - 1];

    for (let i = 0; i < len; i++) {
      const t = masterX[i];

      if (t < srcFirst) {
        result[i] = NaN;
        continue;
      }
      if (t > srcLast) {
        result[i] = NaN;
        continue;
      }

      // Find position using binary search
      const idx = binarySearch(srcX, t);

      if (idx >= srcLen - 1) {
        result[i] = srcY[srcLen - 1];
        continue;
      }

      const t0 = srcX[idx];
      if (t0 === t) {
        result[i] = srcY[idx];
        continue;
      }

      // Sample-and-hold (as per previous logic)
      result[i] = srcY[idx];
    }
    return result;
}
`;
      
      const blob = new Blob([WORKER_CODE], { type: "application/javascript" });
      const worker = new Worker(URL.createObjectURL(blob));
      
      const pendingRequests = new Map();

      worker.onmessage = (e) => {
          const msg = e.data;
          if (msg.type === 'error') {
              console.error("Worker error:", msg.message);
              const req = pendingRequests.get(msg.id);
              if (req) {
                  req.reject(msg.message);
                  pendingRequests.delete(msg.id);
              }
          }
          else if (msg.type === 'parseComplete') {
              const req = pendingRequests.get(msg.id);
              if (req && req.type === 'parse') {
                  req.resolve(msg);
                  pendingRequests.delete(msg.id);
              }
          }
          else if (msg.type === 'interpolateComplete') {
              const req = pendingRequests.get(msg.id);
              if (req && req.type === 'interpolate') {
                  req.resolve(msg.result);
                  pendingRequests.delete(msg.id);
              }
          }
      };

      // Helper to generate IDs
      let msgIdCounter = 0;
      function callWorker(type, payload, transferables = []) {
          return new Promise((resolve, reject) => {
              const id = ++msgIdCounter;
              pendingRequests.set(id, { type, resolve, reject });
              worker.postMessage({ id, type, ...payload }, transferables);
          });
      }

      window.onload = () => {
        if (typeof uPlot === "undefined")
          alert("Помилка: uPlot.iife.min.js не знайдено!");
      };

      async function handleFiles(files) {
        if (!files.length) return;
        const btn = document.querySelector(".btn-primary");
        btn.innerText = "Читання...";
        btn.disabled = true;

        try {
            for (let i = 0; i < files.length; i++) {
                await processFile(files[i]);
            }
        } catch(e) {
            alert("Помилка при читанні: " + e);
        }

        btn.innerText = "+ Завантажити CSV";
        btn.disabled = false;
        document.getElementById("fileInput").value = "";
      }

      async function processFile(file) {
        // Create initial entry in loading state
        const newDs = {
          id: datasets.length,
          name: file.name,
          rawColumns: [],
          config: { xIndex: -1, yIndices: [], expectedFreqHz: 0 },
          anomalies: [],
          isReady: false,
          isLoading: true, // NEW flag
        };
        datasets.push(newDs);
        updateListUI();

        const text = await file.text();
        
        // Offload parsing to worker
        const parsed = await callWorker('parse', { text });
        
        if (!parsed || !parsed.columns) {
            // Remove the dataset if failed
            const idx = datasets.indexOf(newDs);
            if (idx !== -1) datasets.splice(idx, 1);
            updateListUI();
            return alert(`Файл ${file.name} пустий або битий.`);
        }

        newDs.rawColumns = parsed.columns;
        newDs.isLoading = false;

        // Auto-detect config
        if (parsed.columns.length === 2 && parsed.timeIdx !== -1) {
            newDs.config.xIndex = parsed.timeIdx;
            newDs.config.yIndices = [parsed.timeIdx === 0 ? 1 : 0];
            newDs.isReady = true;
            newDs.config.expectedFreqHz = parsed.estimatedFreq;
        }

        updateListUI();

        if (newDs.isReady) {
          // Calculate anomalies for this dataset
          calculateAnomalies(newDs);
          renderAnomalyTabs();
          await renderChart();
        }
      }

      // === UI: LIST & MODAL ===

      function updateListUI() {
        const list = document.getElementById("datasetList");
        list.innerHTML = "";

        datasets.forEach((ds, idx) => {
          const div = document.createElement("div");
          const isMaster = idx === getMasterIndex();
          
          let statusClass = "not-ready";
          if (ds.isLoading) statusClass = "loading";
          else if (ds.isReady) statusClass = isMaster ? "master" : "ready";

          let statusText = "";
          if (ds.isLoading) {
              statusText = "⏳ Обробка...";
          } else if (ds.isReady) {
              statusText = `Готово: X=${ds.rawColumns[ds.config.xIndex].name}, Y=[${ds.config.yIndices.length}]`;
          } else {
              statusText = "⚠️ Потрібне налаштування";
          }

          div.className = `dataset-item ${statusClass}`;
          div.innerHTML = `
                    <div class="ds-header">
                        <div style="display:flex; align-items:center; overflow:hidden;">
                            ${ds.isLoading ? '<span class="spinner"></span>' : ''}
                            <span class="ds-name" title="${ds.name}">${ds.name}</span>
                        </div>
                        ${!ds.isLoading && isMaster ? '<span style="font-size:9px; background:#007bff; padding:1px 3px; border-radius:3px;">MASTER</span>' : ""}
                    </div>
                    <div class="ds-status">${statusText}</div>
                    ${!ds.isLoading ? `
                    <div style="margin-top:8px; display:flex; justify-content:space-between;">
                        <button class="btn-icon ${ds.isReady ? "btn-neutral" : "btn-settings"}" onclick="openConfigModal(${idx})">⚙️ Налаштувати</button>
                        <div>
                             ${ds.isReady ? `<button class="btn-icon btn-fit" onclick="fitY(${idx})" title="Zoom Y">Fit Y</button>` : ""}
                             <button class="btn-icon btn-del" onclick="removeDataset(${idx})">✕</button>
                        </div>
                    </div>` : ''}
                `;
          list.appendChild(div);
        });
      }

      function openConfigModal(idx) {
        activeModalDatasetIndex = idx;
        const ds = datasets[idx];
        const list = document.getElementById("modalColList");
        list.innerHTML = "";

        const suggestX = ds.rawColumns.findIndex((c) =>
          c.name.toLowerCase().includes("timestamp_us"),
        );

        ds.rawColumns.forEach((col, cIdx) => {
          const isX =
            ds.config.xIndex === cIdx ||
            (ds.config.xIndex === -1 && cIdx === suggestX);
          const isY = ds.config.yIndices.includes(cIdx);

          const div = document.createElement("div");
          div.className = "col-item";
          div.innerHTML = `
                    <input type="radio" name="col_x" value="${cIdx}" ${isX ? "checked" : ""}>
                    <input type="checkbox" name="col_y" value="${cIdx}" ${isY ? "checked" : ""}>
                    <span>${col.name}</span>
                `;
          list.appendChild(div);
        });

        // Set frequency field - use existing value or auto-detect
        const freqInput = document.getElementById("modalFreq");
        if (ds.config.expectedFreqHz > 0) {
          freqInput.value = ds.config.expectedFreqHz;
        } else if (suggestX !== -1) {
          freqInput.value = estimateFrequency(ds.rawColumns[suggestX].data);
        } else {
          freqInput.value = "";
        }

        document.getElementById("configModal").style.display = "flex";
      }

      function closeModal() {
        document.getElementById("configModal").style.display = "none";
        activeModalDatasetIndex = -1;
      }

      function applyModalConfig() {
        if (activeModalDatasetIndex === -1) return;

        const list = document.getElementById("modalColList");
        const radioX = list.querySelector('input[name="col_x"]:checked');
        const checksY = list.querySelectorAll('input[name="col_y"]:checked');

        if (!radioX) return alert("Виберіть колонку для осі X!");
        if (checksY.length === 0)
          return alert("Виберіть хоча б одну колонку даних (Y)!");

        const xIdx = parseInt(radioX.value);
        const yIdxs = Array.from(checksY).map((cb) => parseInt(cb.value));

        const ds = datasets[activeModalDatasetIndex];
        ds.config.xIndex = xIdx;
        ds.config.yIndices = yIdxs;

        // Get frequency from input
        const freqInput = document.getElementById("modalFreq");
        ds.config.expectedFreqHz = parseInt(freqInput.value) || 0;
        ds.isReady = true;

        // Calculate anomalies for this dataset
        calculateAnomalies(ds);

        closeModal();
        updateListUI();
        renderAnomalyTabs(); // Update anomaly tabs
        renderChart();
      }

      function removeDataset(idx) {
        // Reset active tab if it was the deleted dataset
        if (activeAnomalyTab === idx) {
          activeAnomalyTab = -1;
        } else if (activeAnomalyTab > idx) {
          activeAnomalyTab--; // Adjust index for shifted datasets
        }

        datasets.splice(idx, 1);
        updateListUI();
        renderAnomalyTabs();
        renderChart();
      }

      // === LOGIC UTILS ===

      function getMasterIndex() {
        return datasets.findIndex((d) => d.isReady);
      }

      function countReadyDatasets() {
        return datasets.filter((d) => d.isReady).length;
      }

      // Estimate frequency from first 1000 samples
      function estimateFrequency(xData) {
        const sampleCount = Math.min(1000, xData.length - 1);
        if (sampleCount <= 0) return 0;
        const totalTime = xData[sampleCount] - xData[0]; // microseconds
        if (totalTime <= 0) return 0;
        const avgInterval = totalTime / sampleCount;
        return Math.round(1000000 / avgInterval); // Hz
      }

      // Calculate anomalies for a dataset based on expected frequency
      function calculateAnomalies(ds) {
        ds.anomalies = [];
        if (!ds.isReady || ds.config.expectedFreqHz <= 0) return;

        const xData = ds.rawColumns[ds.config.xIndex].data;
        const expectedInterval = 1000000 / ds.config.expectedFreqHz; // μs
        const threshold = expectedInterval * 2; // 200% = 2x expected interval

        for (let i = 1; i < xData.length; i++) {
          const diff = xData[i] - xData[i - 1];
          if (diff > threshold) {
            ds.anomalies.push({
              t: xData[i],
              diff: diff,
              expected: expectedInterval,
            });
          }
        }
      }

      // Render anomaly tabs for all ready datasets
      function renderAnomalyTabs() {
        const tabsContainer = document.getElementById("jumpTabs");
        const list = document.getElementById("jumpList");
        tabsContainer.innerHTML = "";
        list.innerHTML = "";

        const readyDatasets = datasets.filter((ds) => ds.isReady);

        if (readyDatasets.length === 0) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Завантажте файли</span>';
          return;
        }

        // Calculate anomalies for all datasets if not done yet
        readyDatasets.forEach((ds) => {
          if (ds.anomalies.length === 0 && ds.config.expectedFreqHz > 0) {
            calculateAnomalies(ds);
          }
        });

        // Create tabs
        readyDatasets.forEach((ds, idx) => {
          const dsIdx = datasets.indexOf(ds);
          const tab = document.createElement("button");
          tab.className =
            "jump-tab" + (activeAnomalyTab === dsIdx ? " active" : "");

          const count = ds.anomalies.length;
          const shortName =
            ds.name.length > 15 ? ds.name.substring(0, 12) + "..." : ds.name;
          tab.innerHTML = `${shortName}<span class="count">${count > 0 ? `(${count})` : "(0)"}</span>`;
          tab.onclick = () => selectAnomalyTab(dsIdx);
          tabsContainer.appendChild(tab);

          // Auto-select first tab if none selected
          if (activeAnomalyTab === -1 && idx === 0) {
            activeAnomalyTab = dsIdx;
            tab.classList.add("active");
          }
        });

        // Render anomalies for active tab
        renderAnomaliesForTab();
      }

      function selectAnomalyTab(dsIdx) {
        activeAnomalyTab = dsIdx;
        // Update tab styles
        document
          .querySelectorAll(".jump-tab")
          .forEach((tab) => tab.classList.remove("active"));
        const tabs = document.querySelectorAll(".jump-tab");
        const readyDatasets = datasets.filter((ds) => ds.isReady);
        const tabIdx = readyDatasets.findIndex(
          (ds) => datasets.indexOf(ds) === dsIdx,
        );
        if (tabIdx >= 0 && tabs[tabIdx]) tabs[tabIdx].classList.add("active");
        renderAnomaliesForTab();
      }

      function renderAnomaliesForTab() {
        const list = document.getElementById("jumpList");
        list.innerHTML = "";

        if (activeAnomalyTab === -1 || !datasets[activeAnomalyTab]) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Виберіть датасет</span>';
          return;
        }

        const ds = datasets[activeAnomalyTab];
        const anomalies = ds.anomalies;

        if (!ds.config.expectedFreqHz || ds.config.expectedFreqHz <= 0) {
          list.innerHTML =
            '<span style="color:#777; padding:5px;">Вкажіть частоту в налаштуваннях</span>';
          return;
        }

        if (anomalies.length === 0) {
          list.innerHTML =
            '<span style="color:#2f9e44; padding:5px;">✓ Норма (немає аномалій)</span>';
          return;
        }

        const limit = Math.min(anomalies.length, 300);
        anomalies.slice(0, limit).forEach((a) => {
          const el = document.createElement("span");
          el.className = "jump-item";
          el.innerHTML = `T:${a.t} <span class="jump-bad">Δ${a.diff.toFixed(0)}</span> (${(a.diff / a.expected).toFixed(1)}x)`;
          el.onclick = () => zoomTo(a.t);
          list.appendChild(el);
        });
        if (anomalies.length > limit) {
          list.innerHTML += `<span style="color:#777; padding:5px;">... ще ${anomalies.length - limit}</span>`;
        }
      }

      // Legacy function - now just calls renderAnomalyTabs
      function recalcJumps() {
        renderAnomalyTabs();
      }

      function renderJumpsList() {
        renderAnomaliesForTab();
      }

      // === CHART RENDERING ===



      async function renderChart() {
        const div = document.getElementById("chart");
        if (uplot) uplot.destroy();
        div.innerHTML = "";

        const mIdx = getMasterIndex();
        if (mIdx === -1) return;

        const masterDs = datasets[mIdx];
        const masterX = masterDs.rawColumns[masterDs.config.xIndex].data;

        const chartData = [masterX];
        const series = [{}];
        const scales = { x: { time: false } };
        const axes = [
          { scale: "x" }, // X axis
        ];

        let globalSeriesCounter = 0;
        
        // Prepare list of series to render and interpolation tasks
        const seriesInfo = [];
        const interpolationPromises = [];

        datasets.forEach((ds, dsIdx) => {
          if (!ds.isReady) return;

          const dsX = ds.rawColumns[ds.config.xIndex].data;
          const isMaster = ds === masterDs;

          ds.config.yIndices.forEach((yIdx) => {
            const colName = ds.rawColumns[yIdx].name;
            const yData = ds.rawColumns[yIdx].data;
            const scaleName = globalSeriesCounter === 0 ? "y" : `y${globalSeriesCounter + 1}`;
            
            // Collect metadata for later use
            seriesInfo.push({
                ds,
                colName,
                yData,
                scaleName,
                isMaster,
                strokeColor: globalSeriesCounter === 0 ? "#00ff00" : PALETTE[(globalSeriesCounter - 1) % PALETTE.length],
                globalIndex: globalSeriesCounter
            });
            
            if (isMaster) {
                // No interpolation needed
                interpolationPromises.push(Promise.resolve(yData));
            } else {
                // Offload interpolation to worker
                interpolationPromises.push(callWorker('interpolate', {
                    srcX: dsX,
                    srcY: yData,
                    masterX: masterX
                }));
            }
            
            globalSeriesCounter++;
          });
        });

        // Wait for all interpolations to finish
        let interpolatedResults;
        try {
            interpolatedResults = await Promise.all(interpolationPromises);
        } catch (e) {
            console.error("Interpolation failed", e);
            alert("Interpolation error: " + e);
            return;
        }

        // Build chart configuration and data
        seriesInfo.forEach((info, idx) => {
            const { ds, colName, inputs, scaleName, strokeColor, globalIndex } = info;
            const yData = interpolatedResults[idx]; // Result from worker or direct pass-through

             // Calculate min/max for this specific column (using the data we are about to plot)
             // Note: if interpolated, we use the interpolated data for range which is correct for view
             // Optimization: Use worker to calc min/max too? For now, main thread is fine for this loop.
            let colMin = Infinity, colMax = -Infinity;
            for (let v of yData) {
              if (!isNaN(v)) {
                if (v < colMin) colMin = v;
                if (v > colMax) colMax = v;
              }
            }
            const range = colMax - colMin || 1;

            scales[scaleName] = {
              auto: true,
              range: [colMin - range * 0.05, colMax + range * 0.05],
            };

            axes.push({
              scale: scaleName,
              side: globalIndex === 0 ? 3 : 1,
              grid: { show: globalIndex === 0 },
              stroke: strokeColor,
              ticks: { stroke: strokeColor },
              label: `${ds.name} (${colName})`,
              labelSize: 30,
            });

            series.push({
              label: `${ds.name} (${colName})`,
              stroke: strokeColor,
              width: 1,
              scale: scaleName,
              points: { show: false },
            });
            
            chartData.push(yData);
        });

        const opts = {
          width: div.clientWidth,
          height: div.clientHeight,
          series: series,
          scales: scales,
          axes: axes,
          cursor: { drag: { x: true, y: true, uni: 50 } },
          legend: { show: false },
          hooks: { setLegend: [updateHoverInfo] },
          plugins: [wheelZoomPlugin({ factor: 0.75 }), middleClickPanPlugin()],
        };

        uplot = new uPlot(opts, chartData, div);
        document.getElementById("dispValues").innerHTML = "";
      }

      function fitY(dsIndex) {
        if (!uplot) return;
        const ds = datasets[dsIndex];

        // Count which series indices belong to this dataset
        let seriesStartIdx = 0;
        for (let i = 0; i < dsIndex; i++) {
          if (datasets[i].isReady) {
            seriesStartIdx += datasets[i].config.yIndices.length;
          }
        }

        // Fit each column's scale
        ds.config.yIndices.forEach((yIdx, colIdx) => {
          const arr = ds.rawColumns[yIdx].data;
          let gMin = Infinity,
            gMax = -Infinity;

          for (let v of arr) {
            if (!isNaN(v)) {
              if (v < gMin) gMin = v;
              if (v > gMax) gMax = v;
            }
          }

          if (gMin !== Infinity) {
            const range = gMax - gMin || 1;
            const seriesIdx = seriesStartIdx + colIdx;
            const scaleName = seriesIdx === 0 ? "y" : `y${seriesIdx + 1}`;

            uplot.setScale(scaleName, {
              min: gMin - range * 0.05,
              max: gMax + range * 0.05,
            });
          }
        });
      }

      function zoomTo(time) {
        if (!uplot) return;
        uplot.setScale("x", { min: time - 5000, max: time + 5000 });
      }

      function updateHoverInfo(u) {
        const idx = u.cursor.idx;
        const tEl = document.getElementById("dispTime");
        const vContainer = document.getElementById("dispValues");

        if (idx === null || idx === undefined) {
          tEl.innerText = "-";
          vContainer.innerHTML = "";
        } else {
          tEl.innerText = u.data[0][idx];

          let html = "";
          for (let i = 1; i < u.series.length; i++) {
            const val = u.data[i][idx];
            const color = u.series[i]._stroke;
            const label = u.series[i].label;
            const shortName =
              label.length > 20 ? label.substring(0, 18) + ".." : label;

            html += `<div style="color:${color}; font-size:12px;">
                        <span style="opacity:0.7">${shortName}:</span> 
                        <b>${isNaN(val) ? "-" : val}</b>
                    </div>`;
          }
          vContainer.innerHTML = html;
        }
      }

      // === PLUGINS ===
      function wheelZoomPlugin(opts) {
        let factor = opts.factor || 0.75;
        return {
          hooks: {
            ready: (u) => {
              u.over.addEventListener("wheel", (e) => {
                e.preventDefault();
                let { left } = u.cursor;
                let leftPct = left / u.bbox.width;
                let xVal = u.posToVal(left, "x");
                let xMin = u.scales.x.min;
                let xMax = u.scales.x.max;
                let xRange = xMax - xMin;
                if (e.deltaY < 0)
                  u.setScale("x", {
                    min: xVal - leftPct * (xRange * factor),
                    max: xVal + (1 - leftPct) * (xRange * factor),
                  });
                else
                  u.setScale("x", {
                    min: xVal - leftPct * (xRange / factor),
                    max: xVal + (1 - leftPct) * (xRange / factor),
                  });
              });
            },
          },
        };
      }
      function middleClickPanPlugin() {
        return {
          hooks: {
            init: (u) => {
              let isPanning = false,
                startX = 0,
                initMin = 0,
                initMax = 0;
              u.over.addEventListener("mousedown", (e) => {
                if (e.button === 1) {
                  e.preventDefault();
                  isPanning = true;
                  startX = e.clientX;
                  initMin = u.scales.x.min;
                  initMax = u.scales.x.max;
                  document.body.style.cursor = "grabbing";
                }
              });
              document.addEventListener("mousemove", (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const dxPx = startX - e.clientX;
                const xRange = initMax - initMin;
                const dxVal = dxPx / (u.bbox.width / xRange);
                u.setScale("x", { min: initMin + dxVal, max: initMax + dxVal });
              });
              document.addEventListener("mouseup", (e) => {
                if (e.button === 1) {
                  isPanning = false;
                  document.body.style.cursor = "default";
                }
              });
            },
          },
        };
      }

      window.addEventListener("resize", () => {
        if (uplot)
          uplot.setSize({
            width: document.getElementById("chart").clientWidth,
            height: document.getElementById("chart").clientHeight,
          });
      });
    </script>
  </body>
</html>
